#usda 1.0
(
    subLayers = [
        @usdGeom/schema.usda@,
        @usdPhysics/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName       = "usdPhysX"
        string libraryPath       = "pxr/usd/usdPhysX"
        string libraryPrefix     = "UsdPhysX"
    }
) {
}

class "PhysxSchemaJointStateAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "JointStateAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "jointState"
    }
    doc = """The PhysicsJointStateAPI is applied to a joint primitive (i.e. any PhysicsJoint-derived type)
    and provides read/write access to the joint position and velocity for a specific joint axis.
    The PhysicsJointStateAPI is a multipleApply schema, and its instance name TfToken defines the joint axis:
    The name can be "transX", "transY", "transZ", "rotX", "rotY", "rotZ"
    or its "linear" for prismatic joint or "angular" for revolute joints, respectively.
"""
)
{
    float physics:position (
        customData = {
            string apiName = "position"
        }
        doc = """Joint state position defines the relative difference between joint body0 frame and joint body1 frame in world frame.
               Range: (-inf, inf) Units: linear - distance angular - degrees"""
    )
    float physics:velocity (
        customData = {
            string apiName = "velocity"
        }
        doc = """Joint state velocity defines the relative velocity between joint body0 and joint body1.
               Range: (-inf, inf) Units: linear - distance / seconds angular - degrees / seconds"""
    )
}

class "PhysxSchemaPhysxArticulationAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ArticulationAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX articulation extended parameters."""
)
{
    bool physxArticulation:articulationEnabled = 1 (
        customData = {
            string apiName = "articulationEnabled"
        }
        doc = """Boolean defining whether articulation is enabled or disabled."""
    )
    bool physxArticulation:enabledSelfCollisions = 1 (
        customData = {
            string apiName = "enabledSelfCollisions"
        }
        doc = """Boolean defining whether self collisions should be enabled or disabled."""
    )
    float physxArticulation:sleepThreshold = 0.00005 (
        customData = {
            string apiName = "sleepThreshold"
        }
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf) Default: 0.00005 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
    int physxArticulation:solverPositionIterationCount = 32 (
        customData = {
            string apiName = "solverPositionIterationCount"
        }
        doc = """Solver position iteration counts for the body.
            Allowed range [1, 255]."""
    )
    int physxArticulation:solverVelocityIterationCount = 1 (
        customData = {
            string apiName = "solverVelocityIterationCount"
        }
        doc = """Solver velocity iteration counts for the body.
            Allowed range [0, 255]."""
    )
    float physxArticulation:stabilizationThreshold = 0.00001 (
        customData = {
            string apiName = "stabilizationThreshold"
        }
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf) Default: 0.00001 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxSchemaPhysxCameraAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera."""
)
{
    bool alwaysUpdateEnabled = 1 (
        customData = {
            string apiName = "alwaysUpdateEnabled"
        }
        doc = """When enabled, always update this camera whether it is the active camera or not.
            This prevents cameras from slewing into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
}

class "PhysxSchemaPhysxCameraDroneAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraDroneAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX drone camera that follows its subject from the air as it drives."""
)
{
    float physxDroneCamera:feedForwardVelocityGain (
        customData = {
            string apiName = "feedForwardVelocityGain"
        }
        doc = """The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"""
    )
    float physxDroneCamera:followDistance (
        customData = {
            string apiName = "followDistance"
        }
        doc = """The distance from the subject that the drone attempts to maintain. e.g. 30 meters"""
    )
    float physxDroneCamera:followHeight (
        customData = {
            string apiName = "followHeight"
        }
        doc = """The height above the subject that the drone attmepts to maintain. e.g. 15 meters"""
    )
    float physxDroneCamera:horizontalVelocityGain (
        customData = {
            string apiName = "horizontalVelocityGain"
        }
        doc = """The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"""
    )
    float physxDroneCamera:maxDistance (
        customData = {
            string apiName = "maxDistance"
        }
        doc = """The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"""
    )
    float physxDroneCamera:maxSpeed (
        customData = {
            string apiName = "maxSpeed"
        }
        doc = """The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"""
    )
    float3 physxDroneCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        doc = """An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"""
    )
    float physxDroneCamera:rotationFilterTimeConstant (
        customData = {
            string apiName = "rotationFilterTimeConstant"
        }
        doc = """The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"""
    )
    float physxDroneCamera:velocityFilterTimeConstant (
        customData = {
            string apiName = "velocityFilterTimeConstant"
        }
        doc = """The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"""
    )
    float physxDroneCamera:verticalVelocityGain (
        customData = {
            string apiName = "verticalVelocityGain"
        }
        doc = """The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"""
    )
}

class "PhysxSchemaPhysxCameraFollowAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraFollowAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject as it moves."""
)
{
    float3 physxFollowCamera:cameraPositionTimeConstant (
        customData = {
            string apiName = "cameraPositionTimeConstant"
        }
        doc = """Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"""
    )
    float physxFollowCamera:followMaxDistance (
        customData = {
            string apiName = "followMaxDistance"
        }
        doc = """The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"""
    )
    float physxFollowCamera:followMaxSpeed (
        customData = {
            string apiName = "followMaxSpeed"
        }
        doc = """The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"""
    )
    float physxFollowCamera:followMinDistance (
        customData = {
            string apiName = "followMinDistance"
        }
        doc = """The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"""
    )
    float physxFollowCamera:followMinSpeed (
        customData = {
            string apiName = "followMinSpeed"
        }
        doc = """The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"""
    )
    float physxFollowCamera:followTurnRateGain (
        customData = {
            string apiName = "followTurnRateGain"
        }
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject.
            Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowFollowCamera:lookAheadMaxDistance (
        customData = {
            string apiName = "lookAheadMaxDistance"
        }
        doc = """The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 500.0 cm"""
    )
    float physxFollowCamera:lookAheadMaxSpeed (
        customData = {
            string apiName = "lookAheadMaxSpeed"
        }
        doc = """The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"""
    )
    float physxFollowCamera:lookAheadMinDistance (
        customData = {
            string apiName = "lookAheadMinDistance"
        }
        doc = """The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"""
    )
    float physxFollowCamera:lookAheadMinSpeed (
        customData = {
            string apiName = "lookAheadMinSpeed"
        }
        doc = """The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"""
    )
    float physxFollowCamera:lookAheadTurnRateGain (
        customData = {
            string apiName = "lookAheadTurnRateGain"
        }
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowCamera:lookPositionHeight (
        customData = {
            string apiName = "lookPositionHeight"
        }
        doc = """Distance to elevate the camera look point. e.g. 50.0 cm"""
    )
    float3 physxFollowCamera:lookPositionTimeConstant (
        customData = {
            string apiName = "lookPositionTimeConstant"
        }
        doc = """Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"""
    )
    float physxFollowCamera:pitchAngle (
        customData = {
            string apiName = "pitchAngle"
        }
        doc = """The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"""
    )
    float physxFollowCamera:pitchAngleTimeConstant (
        customData = {
            string apiName = "pitchAngleTimeConstant"
        }
        doc = """Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"""
    )
    float3 physxFollowCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        doc = """Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"""
    )
    float physxFollowCamera:slowPitchAngleSpeed (
        customData = {
            string apiName = "slowPitchAngleSpeed"
        }
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"""
    )
    float physxFollowCamera:slowSpeedPitchAngleScale (
        customData = {
            string apiName = "slowSpeedPitchAngleScale"
        }
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"""
    )
    float physxFollowCamera:velocityNormalMinSpeed (
        customData = {
            string apiName = "velocityNormalMinSpeed"
        }
        doc = """The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"""
    )
    float physxFollowCamera:yawAngle (
        customData = {
            string apiName = "yawAngle"
        }
        doc = """The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"""
    )
    float physxFollowCamera:yawRateTimeConstant (
        customData = {
            string apiName = "yawRateTimeConstant"
        }
        doc = """Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"""
    )
}

class "PhysxSchemaPhysxCameraFollowLookAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraFollowLookAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject's forward vector as it moves.
        Assumes the subject is always upright and does not roll."""
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        customData = {
            string apiName = "downHillGroundAngle"
        }
        doc = """The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"""
    )
    float physxFollowLookCamera:downHillGroundPitch (
        customData = {
            string apiName = "downHillGroundPitch"
        }
        doc = """The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )
    float physxFollowLookCamera:followReverseDistance (
        customData = {
            string apiName = "followReverseDistance"
        }
        doc = """The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"""
    )
    float physxFollowLookCamera:followReverseSpeed (
        customData = {
            string apiName = "followReverseSpeed"
        }
        doc = """The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"""
    )
    float physxFollowLookCamera:upHillGroundAngle (
        customData = {
            string apiName = "upHillGroundAngle"
        }
        doc = """The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"""
    )
    float physxFollowLookCamera:upHillGroundPitch (
        customData = {
            string apiName = "upHillGroundPitch"
        }
        doc = """The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )
    float physxFollowLookCamera:velocityBlendTimeConstant (
        customData = {
            string apiName = "velocityBlendTimeConstant"
        }
        doc = """Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"""
    )
}

class "PhysxSchemaPhysxCameraFollowVelocityAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraFollowVelocityAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."""
)
{
}

class "PhysxSchemaPhysxCharacterControllerAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CharacterControllerAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysxCharacterControllerAPI can be applied to a capsuleGeom.
        It will turn the capsule into a character controller.
        For any described attribute Fallback Value or Allowed Values below that are text/tokens, 
        the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value."""
)
{
    uniform token physxCharacterController:climbingMode = "easy" (
        customData = {
            string apiName = "climbingMode"
        }
        allowedTokens = ["easy", "constrained"]
        doc = """The climbing mode."""
    )
    float physxCharacterController:contactOffset = 0.1 (
        customData = {
            string apiName = "contactOffset"
        }
        doc = """The contact offset used by the controller. Range: [0, inf) Units: distance"""
    )
    float physxCharacterController:invisibleWallHeight = 0 (
        customData = {
            string apiName = "invisibleWallHeight"
        }
        doc = """Height of invisible walls created around non-walkable triangles. Range: [0, inf) Units: distance"""
    )
    float physxCharacterController:maxJumpHeight = 0 (
        customData = {
            string apiName = "maxJumpHeight"
        }
        doc = """Maximum height a jumping character can reach. Range: [0, inf) Units: distance"""
    )
    vector3f physxCharacterController:moveTarget = (0, 0, 0) (
        customData = {
            string apiName = "moveTarget"
        }
        doc = """Desired target position that CCT should try to reach."""
    )
    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        customData = {
            string apiName = "nonWalkableMode"
        }
        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        doc = """The non-walkable mode controls if a character controller slides or not on a non-walkable part."""
    )
    float physxCharacterController:scaleCoeff = 0.8 (
        customData = {
            string apiName = "scaleCoeff"
        }
        doc = """Scale coefficient for underlying kinematic actor. Range: [0, inf) Units: dimensionless"""
    )
    float physxCharacterController:slopeLimit = 0.3 (
        customData = {
            string apiName = "slopeLimit"
        }
        doc = """Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. A value of 0 disables this feature."""
    )
    float physxCharacterController:stepOffset = 0.5 (
        customData = {
            string apiName = "stepOffset"
        }
        doc = """Defines the maximum height of an obstacle which the character can climb. Range: [0, inf) Units: distance"""
    )
    uniform token physxCharacterController:upAxis = "Z" (
        customData = {
            string apiName = "upAxis"
        }
        allowedTokens = ["X", "Y", "Z"]
        doc = """Up axis for stepping functionality."""
    )
    float physxCharacterController:volumeGrowth = 1.5 (
        customData = {
            string apiName = "volumeGrowth"
        }
        doc = """Cached volume growth. Range: [0, inf) Units: dimensionless"""
    )
}

class "PhysxSchemaPhysxCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX collision extended parameters."""
)
{
    float physxCollision:contactOffset = -inf (
        customData = {
            string apiName = "contactOffset"
        }
        doc = """Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent. Range: [maximum(0, restOffset), inf) Units: distance"""
    )
    float physxCollision:minTorsionalPatchRadius = 0 (
        customData = {
            string apiName = "minTorsionalPatchRadius"
        }
        doc = """Defines the minimum radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"""
    )
    float physxCollision:restOffset = -inf (
        customData = {
            string apiName = "restOffset"
        }
        doc = """Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value. For rigid bodies, this value is zero. Range: [0, contactOffset] Units: distance"""
    )
    float physxCollision:torsionalPatchRadius = 0 (
        customData = {
            string apiName = "torsionalPatchRadius"
        }
        doc = """Defines the radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"""
    )
}

class "PhysxSchemaPhysxContactReportAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ContactReportAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """Enables contact reporting for a rigid body or articulation."""
)
{
    float physxContactReport:threshold = 1 (
        customData = {
            string apiName = "threshold"
        }
        doc = """Sets the force threshold for contact reports. Range: [0, inf] Units: force = mass * distance / seconds^2"""
    )
}

class "PhysxSchemaPhysxConvexDecompositionCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ConvexDecompositionCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX convex decomposition(VHACD) extended parameters."""
)
{
    float physxConvexDecompositionCollision:errorPercentage = 10 (
        customData = {
            string apiName = "errorPercentage"
        }
        doc = """Convex decomposition errorPercentage parameter."""
    )
    int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }
        doc = """Convex hull vertex limit used for convex hull cooking."""
    )
    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        customData = {
            string apiName = "maxConvexHulls"
        }
        doc = """Maximum of convex hulls created during convex decomposition."""
    )
    float physxConvexDecompositionCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }
        doc = """Convex hull min thickness. Range: [0, inf) Units: distance"""
    )
    bool physxConvexDecompositionCollision:shrinkWrap = 0 (
        customData = {
            string apiName = "shrinkWrap"
        }
        doc = """Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."""
    )
    int physxConvexDecompositionCollision:voxelResolution = 500000 (
        customData = {
            string apiName = "voxelResolution"
        }
        doc = """Voxel resolution used for convex decomposition."""
    )
}

class "PhysxSchemaPhysxConvexHullCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ConvexHullCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX convex hull collision extended parameters."""
)
{
    int physxConvexHullCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }
        doc = """Convex hull vertex limit used for convex hull cooking."""
    )
    float physxConvexHullCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }
        doc = """Convex hull minimum thickness. Range: [0, inf) Units: distance"""
    )
}

class "PhysxSchemaPhysxCookedDataAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CookedDataAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "physxCookedData"
    }
    doc = """PhysX cooked data storage."""
)
{
    uchar[] buffer (
        customData = {
            string apiName = "buffer"
        }
        doc = """CookedData"""
    )
}

class "PhysxSchemaPhysxForceAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ForceAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """
        PhysX schema API that applies a force and torque to a rigid body (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI).

        The API can be applied to either:

        The rigid-body Xformable, in which case the force is applied at the body's center of mass.
        To an UsdGeom.Xformable that is a child of the rigid-body Xformable, in which case the force is applied at the location defined by the Xformable.
        The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. Note that any scale transform operations will only affect the force and torque values if on "acceleration" mode.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    vector3f physxForce:force = (0, 0, 0) (
        customData = {
            string apiName = "force"
        }
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled.

        The force is applied at the position defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied directly to a rigid-body Xformable. For units see mode attribute. Range: (-inf, inf)
    """
    )
    bool physxForce:forceEnabled = 1 (
        customData = {
            string apiName = "forceEnabled"
        }
        doc = """Boolean defining whether the force and torque are enabled or disabled."""
    )
    uniform token physxForce:mode = "acceleration" (
        customData = {
            string apiName = "mode"
        }
        allowedTokens = ["acceleration", "force"]
        doc = """
        Force mode, can be either a force or an acceleration.

        force - units: (linear) mass * distance / seconds^2, i.e. a force (angular) mass * distance * distance / time^2, 
        i.e. a torque acceleration - units: (linear) distance / seconds^2, i.e. a linear acceleration. (angular) degrees / seconds^2, i.e. an angular acceleration.
        """
    )
    vector3f physxForce:torque = (0, 0, 0) (
        customData = {
            string apiName = "torque"
        }
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled.
            For units see mode attribute. Range: (-inf, inf)"""
    )
    bool physxForce:worldFrameEnabled = 0 (
        customData = {
            string apiName = "worldFrameEnabled"
        }
        doc = """Boolean defining whether the force and torque are in world frame or in local frame."""
    )
}

class "PhysxSchemaPhysxIsosurfaceAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "IsosurfaceAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """Applied to a PhysxParticleSystem.
        Defines settings to extract an isosurface from the particles in the particle system."""
)
{
    float physxIsosurface:anisotropyMax = 2 (
        customData = {
            string apiName = "anisotropyMax"
        }
        doc = """The maximal scale anisotropy can apply to a particle radius.
            Range: [anisotropyMin, inf) Units: dimensionless"""
    )
    float physxIsosurface:anisotropyMin = 0.1 (
        customData = {
            string apiName = "anisotropyMin"
        }
        doc = """The minimal scale anisotropy can apply to a particle radius.
            Range: [0, anisotropyMax] Units: dimensionless"""
    )
    float physxIsosurface:anisotropyRadius = 0.5 (
        customData = {
            string apiName = "anisotropyRadius"
        }
        doc = """Radius that defines the size of the neighborhood used to determine the anisotropy information.
            Range: [0, inf) Units: distance"""
    )
    bool physxIsosurface:enableAnisotropy = 0 (
        customData = {
            string apiName = "enableAnisotropy"
        }
        doc = """Enables usage of anisotropy information during isosurface extraction process."""
    )
    string physxIsosurface:gridFilteringPasses = "GSRS" (
        customData = {
            string apiName = "gridFilteringPasses"
        }
        doc = """Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. 
        Up to 8 passes, every pass can consist of up to 4 repetitions."""
    )
    float physxIsosurface:gridSmoothingRadiusRelativeToCellSize = 0.5 (
        customData = {
            string apiName = "gridSmoothingRadiusRelativeToCellSize"
        }
        doc = """The radius used during the smoothing process on the grid.
        It is measured relative to the grid's cell size. Range: [0, inf) Units: dimensionless"""
    )
    float physxIsosurface:gridSpacing = 0.25 (
        customData = {
            string apiName = "gridSpacing"
        }
        doc = """Cell Size of the grid used for isosurface extraction.
        Range: (0, inf) Units: distance"""
    )
    bool physxIsosurface:isoSurfaceEnabled = 1 (
        customData = {
            string apiName = "isoSurfaceEnabled"
        }
        doc = """Enable or disable the creation of an isosurface."""
    )
    float physxIsosurface:isosurfaceLevel = -0.3 (
        customData = {
            string apiName = "isosurfaceLevel"
        }
        doc = """The level at which the isosurface is located.
        Allows to control the droplet size. The signed distance field is more negative towards the center of the fluid and positive outside. Range: (-inf, inf) Units: distance"""
    )
    float physxIsosurface:kernelRadius = 0.5 (
        customData = {
            string apiName = "kernelRadius"
        }
        doc = """Radius of the kernel used to transfer the density to the isosurface grid.
        Range: (0, inf) Units: distance"""
    )
    int physxIsosurface:maxSubgrids = 1024 (
        customData = {
            string apiName = "maxSubgrids"
        }
        doc = """Maximum number of blocks the sparse grid structure can contain.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxTriangles = 2097152 (
        customData = {
            string apiName = "maxTriangles"
        }
        doc = """Maximum number of triangles the extracted isosurface can have.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxVertices = 1048576 (
        customData = {
            string apiName = "maxVertices"
        }
        doc = """Maximum number of vertices the extracted isosurface can have.
        Range: [3, inf)"""
    )
    int physxIsosurface:numMeshSmoothingPasses = 2 (
        customData = {
            string apiName = "numMeshSmoothingPasses"
        }
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
        Using an even number of passes leads to less shrinking. Range: [0, inf)"""
    )
}

class "PhysxSchemaPhysxJointAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "JointAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX joint extended parameters."""
)
{
    float physxJoint:armature = 0 (
        customData = {
            string apiName = "armature"
        }
        doc = """Armature can help stabilize an articulation by adding to the inertial response of a joint.
        Conceptually, armature represents the inertia of an actuator driving the joint. Note that this parameter is used only when the joint belongs to an articulation. 
        Range: [0, inf) Units: Linear joint - mass Angular joint - mass * (distance)^2
        """
    )
    bool physxJoint:enableProjection = 0 (
        customData = {
            string apiName = "enableProjection"
        }
        doc = """Whether the actors should get projected for this constraint (the direction will be chosen by PhysX)."""
    )
    float physxJoint:jointFriction = 0 (
        customData = {
            string apiName = "jointFriction"
        }
        doc = """Joint friction.
        Only applies for joints that are parts of an articulation. Range: [0, inf) Units: dimensionless"""
    )
    float physxJoint:maxJointVelocity = 1000000 (
        customData = {
            string apiName = "maxJointVelocity"
        }
        doc = """Maximum joint velocity.
        Range: [0, inf) Units: Linear joint - distance / time Angular joint - degrees / time"""
    )
}

class "PhysxSchemaPhysxMaterialAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "MaterialAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX material extended parameters.
    For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. 
    So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    bool physxMaterial:compliantContactAccelerationSpring = 0 (
        customData = {
            string apiName = "compliantContactAccelerationSpring"
        }
        doc = """If enabled, switches from force-based to acceleration-based compliant spring-damper contact effects.
        An acceleration-based spring-damper directly influences the acceleration of (rather than the force on) the contacting bodies, 
        which makes the sink-in depth independent of the mass. The setting has no effect if compliant contacts are disabled, i.e., if the compliant contact stiffness is zero.
        """
    )
    float physxMaterial:compliantContactDamping = 0 (
        customData = {
            string apiName = "compliantContactDamping"
        }
        doc = """Damping coefficient for a compliant contact model using implicit springs.

        Ignored if compliant contacts are disabled (compliantContactStiffness is set to zero), in which case rigid contacts are active. 
        Depending on the compliantContactAccelerationSpring setting, the damping is interpreted as a force or acceleration, respectively, per unit velocity. 
        Range: [0, inf) Units (force spring): force / (distance / seconds) = mass / seconds Units (acceleration spring): acceleration / (distance / seconds) = 1 / seconds
        """
    )
    float physxMaterial:compliantContactStiffness = 0 (
        customData = {
            string apiName = "compliantContactStiffness"
        }
        doc = """Spring stiffness for a compliant contact model using implicit springs.

        A higher stiffness results in behavior closer to a rigid contact. The compliant contact model is only enabled if the stiffness is larger than 0. 
        Depending on the compliantContactAccelerationSpring setting, the stiffness is interpreted as a force or acceleration, respectively, per unit distance. 
        Range: [0, inf) Units (force spring): force/distance = mass / seconds / seconds Units (acceleration spring): acceleration/distance = 1 / seconds / seconds
        """
    )
    uniform token physxMaterial:dampingCombineMode = "average" (
        customData = {
            string apiName = "dampingCombineMode"
        }
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a damping coefficient for a collision.

        This value is only relevant for compliant contact interactions.
        """
    )
    uniform token physxMaterial:frictionCombineMode = "average" (
        customData = {
            string apiName = "frictionCombineMode"
        }
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a friction coefficient for a collision.
        """
    )
    uniform token physxMaterial:restitutionCombineMode = "average" (
        customData = {
            string apiName = "restitutionCombineMode"
        }
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a restitution coefficient for a collision.
        """
    )
}

class "PhysxSchemaPhysxMeshMergeCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "MeshMergeCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysxMeshMergeCollisionAPI enables implicit mesh merging of given meshes with respect to physics collision geometry representation.

    It is expected that this API extends the UsdPhysics.CollisionAPI definition, the UsdPhysics.CollisionAPI is still required to be present together with this API to define the collision properties. All meshes that belong to the collisionmeshes collection will be merged into one mesh that will be used for collision representation. Note that the collection can also define what meshes should be excluded from the selection.

    This means that for example all meshes that belong to the collection will be represented as one convexHull rather than dozens of convexHulls per mesh.

    It is possible to collect meshes through the collection that do not belong to the same hierarchy. This is allowed, however if the collisions are part of a rigid body, the meshes that do not belong to the rigid body hierarchy wont move. As defined in the rigid body specification, only rigid body transformation is updated.

    Note that any changes to the meshes during runtime will get ignored.
    """
)
{
}

class "PhysxSchemaPhysxMimicJointAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "MimicJointAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "physxMimicJoint"
    }
    doc = """Applied to a Physics Joint that must be part of an articulation.

    Supported joint types are: PhysicsRevoluteJoint (with a limit set), PhysicsPrismaticJoint as well as the more generic PhysicsJoint if all linear degrees of freedom are locked.

    This schema allows to interconnect the degrees of freedom of two joints according to the relationship: jointPosition + (gearing * referenceJointPosition) + offset = 0. This can be used to have, for example, one joint mimic the motion of another joint. The term "position" does not necessarily mean a translational unit, in the case of an angular degree of freedom it is an angle. The mimic joint operates on a single degree of freedom which is specified through the instance name of this multiple apply schema. The allowed instance name tokens are "rotX", "rotY" and "rotZ". See the documentation of the attribute referenceJointAxis for more info related to specifying the degree of freedom to operate on. Notes: 1) the two joints have to be part of the same articulation. 2) once the simulation has started, a significant performance penalty will be incurred if a mimic joint is added or removed, if the referenceJoint relationship is changed or if the referenceJointAxis attributes is modified. 3) the mimic joint relationship is interpreted as a two-way interaction and an impulse will get applied to the reference joint as well.

    For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    float gearing = 1 (
        customData = {
            string apiName = "gearing"
        }
        doc = """The gearing coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
        Range: (-inf, inf) Units: unitless or degrees/distance or distance/degrees (the last two refer to scenarios where a linear degree of freedom is connected to an angular one or vice versa)
        """
    )
    float offset = 0 (
        customData = {
            string apiName = "offset"
        }
        doc = """The offset coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
        Range: (-inf, inf) Units: distance or degrees (depending on whether the mimic joint's degree of freedom is linear or angular)
        """
    )
    uniform token referenceJointAxis = "rotX" (
        customData = {
            string apiName = "referenceJointAxis"
        }
        allowedTokens = ["rotX", "rotY", "rotZ"]
        doc = """
        The axis that marks the degree of freedom of the reference joint to mimic.

        Has to be a valid degree of freedom on the reference joint. For joint types with a single degree of freedom (like PhysicsRevoluteJoint or PhysicsPrismaticJoint), 
        this attribute will be ignored since the axis is defined implicitly. 
        The mimic joint connects <targetJoint, targetJointAxis> to <referenceJoint, referenceJointAxis> with targetJoint being the prim that has PhysxMimicJointAPI applied 
        and targetJointAxis being defined through the instance name token of PhysxMimicJointAPI.
        """
    )
}

class "PhysxSchemaPhysxPhysicsDistanceJointAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "PhysicsDistanceJointAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX distance joint extended parameters."""
)
{
    float physxPhysicsDistanceJoint:springDamping = 0 (
        customData = {
            string apiName = "springDamping"
        }
        doc = """Spring damping.
        Range: [0, inf) Units: force * seconds / distance = mass / seconds
        """
    )
    bool physxPhysicsDistanceJoint:springEnabled = 0 (
        customData = {
            string apiName = "springEnabled"
        }
        doc = """Whether spring should be enabled.
        (default off)
        """
    )
    float physxPhysicsDistanceJoint:springStiffness = 0 (
        customData = {
            string apiName = "springStiffness"
        }
        doc = """Spring stiffness.
        Range: [0, inf) Units: force / distance = mass / seconds^2
        """
    )
}



class PhysxSchemaPhysxPhysicsGearJoint "PhysxSchemaPhysxPhysicsGearJoint" (
    doc = """Predefined gear joint type."""
    # Inherits from </SimplePrim> defined in simple.usda.
    inherits = </PhysicsJoint>
    customData = {
        string className = "PhysicsGearJoint"
    }
)  {
    float physics:gearRatio = 1 (
        doc = """Gear ratio Range: (-inf, inf) Units: dimensionless."""
    )
}

class PhysxSchemaPhysxPhysicsInstancer "PhysxSchemaPhysxPhysicsInstancer" (
    doc = """Core class for instancing physics prims."""
    # Inherits from </SimplePrim> defined in simple.usda.
    inherits = </Imageable>
    customData = {
        string className = "PhysicsInstancer"
    }
)  {
    int[] physics:protoIndices (
        doc = "Per-instance index into prototypes relationship that identifies what physics prims are instanced. Topology attribute - can be animated, but at a potential performance impact for streaming."
    )
}