#usda 1.0
(
    subLayers = [
        @usdGeom/schema.usda@,
        @usdPhysics/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName       = "usdPhysX"
        string libraryPath       = "pxr/usd/usdPhysX"
        string libraryPrefix     = "UsdPhysX"
    }
) {
}

class "PhysxSchemaJointStateAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "JointStateAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "jointState"
    }
    doc = """The PhysicsJointStateAPI is applied to a joint primitive (i.e. any PhysicsJoint-derived type)
    and provides read/write access to the joint position and velocity for a specific joint axis.
    The PhysicsJointStateAPI is a multipleApply schema, and its instance name TfToken defines the joint axis:
    The name can be "transX", "transY", "transZ", "rotX", "rotY", "rotZ"
    or its "linear" for prismatic joint or "angular" for revolute joints, respectively.
"""
)
{
    float physics:position (
        customData = {
            string apiName = "position"
        }
        doc = """Joint state position defines the relative difference between joint body0 frame and joint body1 frame in world frame.
               Range: (-inf, inf) Units: linear - distance angular - degrees"""
    )
    float physics:velocity (
        customData = {
            string apiName = "velocity"
        }
        doc = """Joint state velocity defines the relative velocity between joint body0 and joint body1.
               Range: (-inf, inf) Units: linear - distance / seconds angular - degrees / seconds"""
    )
}

class "PhysxSchemaPhysxArticulationAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ArticulationAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX articulation extended parameters."""
)
{
    bool physxArticulation:articulationEnabled = 1 (
        customData = {
            string apiName = "articulationEnabled"
        }
        doc = """Boolean defining whether articulation is enabled or disabled."""
    )
    bool physxArticulation:enabledSelfCollisions = 1 (
        customData = {
            string apiName = "enabledSelfCollisions"
        }
        doc = """Boolean defining whether self collisions should be enabled or disabled."""
    )
    float physxArticulation:sleepThreshold = 0.00005 (
        customData = {
            string apiName = "sleepThreshold"
        }
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf) Default: 0.00005 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
    int physxArticulation:solverPositionIterationCount = 32 (
        customData = {
            string apiName = "solverPositionIterationCount"
        }
        doc = """Solver position iteration counts for the body.
            Allowed range [1, 255]."""
    )
    int physxArticulation:solverVelocityIterationCount = 1 (
        customData = {
            string apiName = "solverVelocityIterationCount"
        }
        doc = """Solver velocity iteration counts for the body.
            Allowed range [0, 255]."""
    )
    float physxArticulation:stabilizationThreshold = 0.00001 (
        customData = {
            string apiName = "stabilizationThreshold"
        }
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf) Default: 0.00001 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxSchemaPhysxCameraAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera."""
)
{
    bool alwaysUpdateEnabled = 1 (
        customData = {
            string apiName = "alwaysUpdateEnabled"
        }
        doc = """When enabled, always update this camera whether it is the active camera or not.
            This prevents cameras from slewing into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
}

class "PhysxSchemaPhysxCameraDroneAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraDroneAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX drone camera that follows its subject from the air as it drives."""
)
{
    float physxDroneCamera:feedForwardVelocityGain (
        customData = {
            string apiName = "feedForwardVelocityGain"
        }
        doc = """The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"""
    )
    float physxDroneCamera:followDistance (
        customData = {
            string apiName = "followDistance"
        }
        doc = """The distance from the subject that the drone attempts to maintain. e.g. 30 meters"""
    )
    float physxDroneCamera:followHeight (
        customData = {
            string apiName = "followHeight"
        }
        doc = """The height above the subject that the drone attmepts to maintain. e.g. 15 meters"""
    )
    float physxDroneCamera:horizontalVelocityGain (
        customData = {
            string apiName = "horizontalVelocityGain"
        }
        doc = """The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"""
    )
    float physxDroneCamera:maxDistance (
        customData = {
            string apiName = "maxDistance"
        }
        doc = """The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"""
    )
    float physxDroneCamera:maxSpeed (
        customData = {
            string apiName = "maxSpeed"
        }
        doc = """The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"""
    )
    float3 physxDroneCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        doc = """An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"""
    )
    float physxDroneCamera:rotationFilterTimeConstant (
        customData = {
            string apiName = "rotationFilterTimeConstant"
        }
        doc = """The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"""
    )
    float physxDroneCamera:velocityFilterTimeConstant (
        customData = {
            string apiName = "velocityFilterTimeConstant"
        }
        doc = """The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"""
    )
    float physxDroneCamera:verticalVelocityGain (
        customData = {
            string apiName = "verticalVelocityGain"
        }
        doc = """The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"""
    )
}

class "PhysxSchemaPhysxCameraFollowAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraFollowAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject as it moves."""
)
{
    float3 physxFollowCamera:cameraPositionTimeConstant (
        customData = {
            string apiName = "cameraPositionTimeConstant"
        }
        doc = """Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"""
    )
    float physxFollowCamera:followMaxDistance (
        customData = {
            string apiName = "followMaxDistance"
        }
        doc = """The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"""
    )
    float physxFollowCamera:followMaxSpeed (
        customData = {
            string apiName = "followMaxSpeed"
        }
        doc = """The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"""
    )
    float physxFollowCamera:followMinDistance (
        customData = {
            string apiName = "followMinDistance"
        }
        doc = """The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"""
    )
    float physxFollowCamera:followMinSpeed (
        customData = {
            string apiName = "followMinSpeed"
        }
        doc = """The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"""
    )
    float physxFollowCamera:followTurnRateGain (
        customData = {
            string apiName = "followTurnRateGain"
        }
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject.
            Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowFollowCamera:lookAheadMaxDistance (
        customData = {
            string apiName = "lookAheadMaxDistance"
        }
        doc = """The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 500.0 cm"""
    )
    float physxFollowCamera:lookAheadMaxSpeed (
        customData = {
            string apiName = "lookAheadMaxSpeed"
        }
        doc = """The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"""
    )
    float physxFollowCamera:lookAheadMinDistance (
        customData = {
            string apiName = "lookAheadMinDistance"
        }
        doc = """The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"""
    )
    float physxFollowCamera:lookAheadMinSpeed (
        customData = {
            string apiName = "lookAheadMinSpeed"
        }
        doc = """The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"""
    )
    float physxFollowCamera:lookAheadTurnRateGain (
        customData = {
            string apiName = "lookAheadTurnRateGain"
        }
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowCamera:lookPositionHeight (
        customData = {
            string apiName = "lookPositionHeight"
        }
        doc = """Distance to elevate the camera look point. e.g. 50.0 cm"""
    )
    float3 physxFollowCamera:lookPositionTimeConstant (
        customData = {
            string apiName = "lookPositionTimeConstant"
        }
        doc = """Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"""
    )
    float physxFollowCamera:pitchAngle (
        customData = {
            string apiName = "pitchAngle"
        }
        doc = """The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"""
    )
    float physxFollowCamera:pitchAngleTimeConstant (
        customData = {
            string apiName = "pitchAngleTimeConstant"
        }
        doc = """Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"""
    )
    float3 physxFollowCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        doc = """Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"""
    )
    float physxFollowCamera:slowPitchAngleSpeed (
        customData = {
            string apiName = "slowPitchAngleSpeed"
        }
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"""
    )
    float physxFollowCamera:slowSpeedPitchAngleScale (
        customData = {
            string apiName = "slowSpeedPitchAngleScale"
        }
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"""
    )
    float physxFollowCamera:velocityNormalMinSpeed (
        customData = {
            string apiName = "velocityNormalMinSpeed"
        }
        doc = """The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"""
    )
    float physxFollowCamera:yawAngle (
        customData = {
            string apiName = "yawAngle"
        }
        doc = """The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"""
    )
    float physxFollowCamera:yawRateTimeConstant (
        customData = {
            string apiName = "yawRateTimeConstant"
        }
        doc = """Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"""
    )
}

class "PhysxSchemaPhysxCameraFollowLookAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraFollowLookAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject's forward vector as it moves.
        Assumes the subject is always upright and does not roll."""
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        customData = {
            string apiName = "downHillGroundAngle"
        }
        doc = """The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"""
    )
    float physxFollowLookCamera:downHillGroundPitch (
        customData = {
            string apiName = "downHillGroundPitch"
        }
        doc = """The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )
    float physxFollowLookCamera:followReverseDistance (
        customData = {
            string apiName = "followReverseDistance"
        }
        doc = """The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"""
    )
    float physxFollowLookCamera:followReverseSpeed (
        customData = {
            string apiName = "followReverseSpeed"
        }
        doc = """The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"""
    )
    float physxFollowLookCamera:upHillGroundAngle (
        customData = {
            string apiName = "upHillGroundAngle"
        }
        doc = """The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"""
    )
    float physxFollowLookCamera:upHillGroundPitch (
        customData = {
            string apiName = "upHillGroundPitch"
        }
        doc = """The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )
    float physxFollowLookCamera:velocityBlendTimeConstant (
        customData = {
            string apiName = "velocityBlendTimeConstant"
        }
        doc = """Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"""
    )
}

class "PhysxSchemaPhysxCameraFollowVelocityAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CameraFollowVelocityAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."""
)
{
}

class "PhysxSchemaPhysxCharacterControllerAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CharacterControllerAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysxCharacterControllerAPI can be applied to a capsuleGeom.
        It will turn the capsule into a character controller.
        For any described attribute Fallback Value or Allowed Values below that are text/tokens, 
        the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value."""
)
{
    uniform token physxCharacterController:climbingMode = "easy" (
        customData = {
            string apiName = "climbingMode"
        }
        allowedTokens = ["easy", "constrained"]
        doc = """The climbing mode."""
    )
    float physxCharacterController:contactOffset = 0.1 (
        customData = {
            string apiName = "contactOffset"
        }
        doc = """The contact offset used by the controller. Range: [0, inf) Units: distance"""
    )
    float physxCharacterController:invisibleWallHeight = 0 (
        customData = {
            string apiName = "invisibleWallHeight"
        }
        doc = """Height of invisible walls created around non-walkable triangles. Range: [0, inf) Units: distance"""
    )
    float physxCharacterController:maxJumpHeight = 0 (
        customData = {
            string apiName = "maxJumpHeight"
        }
        doc = """Maximum height a jumping character can reach. Range: [0, inf) Units: distance"""
    )
    vector3f physxCharacterController:moveTarget = (0, 0, 0) (
        customData = {
            string apiName = "moveTarget"
        }
        doc = """Desired target position that CCT should try to reach."""
    )
    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        customData = {
            string apiName = "nonWalkableMode"
        }
        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        doc = """The non-walkable mode controls if a character controller slides or not on a non-walkable part."""
    )
    float physxCharacterController:scaleCoeff = 0.8 (
        customData = {
            string apiName = "scaleCoeff"
        }
        doc = """Scale coefficient for underlying kinematic actor. Range: [0, inf) Units: dimensionless"""
    )
    float physxCharacterController:slopeLimit = 0.3 (
        customData = {
            string apiName = "slopeLimit"
        }
        doc = """Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. A value of 0 disables this feature."""
    )
    float physxCharacterController:stepOffset = 0.5 (
        customData = {
            string apiName = "stepOffset"
        }
        doc = """Defines the maximum height of an obstacle which the character can climb. Range: [0, inf) Units: distance"""
    )
    uniform token physxCharacterController:upAxis = "Z" (
        customData = {
            string apiName = "upAxis"
        }
        allowedTokens = ["X", "Y", "Z"]
        doc = """Up axis for stepping functionality."""
    )
    float physxCharacterController:volumeGrowth = 1.5 (
        customData = {
            string apiName = "volumeGrowth"
        }
        doc = """Cached volume growth. Range: [0, inf) Units: dimensionless"""
    )
}

class "PhysxSchemaPhysxCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX collision extended parameters."""
)
{
    float physxCollision:contactOffset = -inf (
        customData = {
            string apiName = "contactOffset"
        }
        doc = """Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent. Range: [maximum(0, restOffset), inf) Units: distance"""
    )
    float physxCollision:minTorsionalPatchRadius = 0 (
        customData = {
            string apiName = "minTorsionalPatchRadius"
        }
        doc = """Defines the minimum radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"""
    )
    float physxCollision:restOffset = -inf (
        customData = {
            string apiName = "restOffset"
        }
        doc = """Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value. For rigid bodies, this value is zero. Range: [0, contactOffset] Units: distance"""
    )
    float physxCollision:torsionalPatchRadius = 0 (
        customData = {
            string apiName = "torsionalPatchRadius"
        }
        doc = """Defines the radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"""
    )
}

class "PhysxSchemaPhysxContactReportAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ContactReportAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """Enables contact reporting for a rigid body or articulation."""
)
{
    float physxContactReport:threshold = 1 (
        customData = {
            string apiName = "threshold"
        }
        doc = """Sets the force threshold for contact reports. Range: [0, inf] Units: force = mass * distance / seconds^2"""
    )
}

class "PhysxSchemaPhysxConvexDecompositionCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ConvexDecompositionCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX convex decomposition(VHACD) extended parameters."""
)
{
    float physxConvexDecompositionCollision:errorPercentage = 10 (
        customData = {
            string apiName = "errorPercentage"
        }
        doc = """Convex decomposition errorPercentage parameter."""
    )
    int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }
        doc = """Convex hull vertex limit used for convex hull cooking."""
    )
    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        customData = {
            string apiName = "maxConvexHulls"
        }
        doc = """Maximum of convex hulls created during convex decomposition."""
    )
    float physxConvexDecompositionCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }
        doc = """Convex hull min thickness. Range: [0, inf) Units: distance"""
    )
    bool physxConvexDecompositionCollision:shrinkWrap = 0 (
        customData = {
            string apiName = "shrinkWrap"
        }
        doc = """Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."""
    )
    int physxConvexDecompositionCollision:voxelResolution = 500000 (
        customData = {
            string apiName = "voxelResolution"
        }
        doc = """Voxel resolution used for convex decomposition."""
    )
}

class "PhysxSchemaPhysxConvexHullCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ConvexHullCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX convex hull collision extended parameters."""
)
{
    int physxConvexHullCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }
        doc = """Convex hull vertex limit used for convex hull cooking."""
    )
    float physxConvexHullCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }
        doc = """Convex hull minimum thickness. Range: [0, inf) Units: distance"""
    )
}

class "PhysxSchemaPhysxCookedDataAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "CookedDataAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "physxCookedData"
    }
    doc = """PhysX cooked data storage."""
)
{
    uchar[] buffer (
        customData = {
            string apiName = "buffer"
        }
        doc = """CookedData"""
    )
}

class "PhysxSchemaPhysxForceAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ForceAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """
        PhysX schema API that applies a force and torque to a rigid body (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI).

        The API can be applied to either:

        The rigid-body Xformable, in which case the force is applied at the body's center of mass.
        To an UsdGeom.Xformable that is a child of the rigid-body Xformable, in which case the force is applied at the location defined by the Xformable.
        The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. Note that any scale transform operations will only affect the force and torque values if on "acceleration" mode.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    vector3f physxForce:force = (0, 0, 0) (
        customData = {
            string apiName = "force"
        }
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled.

        The force is applied at the position defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied directly to a rigid-body Xformable. For units see mode attribute. Range: (-inf, inf)
    """
    )
    bool physxForce:forceEnabled = 1 (
        customData = {
            string apiName = "forceEnabled"
        }
        doc = """Boolean defining whether the force and torque are enabled or disabled."""
    )
    uniform token physxForce:mode = "acceleration" (
        customData = {
            string apiName = "mode"
        }
        allowedTokens = ["acceleration", "force"]
        doc = """
        Force mode, can be either a force or an acceleration.

        force - units: (linear) mass * distance / seconds^2, i.e. a force (angular) mass * distance * distance / time^2, 
        i.e. a torque acceleration - units: (linear) distance / seconds^2, i.e. a linear acceleration. (angular) degrees / seconds^2, i.e. an angular acceleration.
        """
    )
    vector3f physxForce:torque = (0, 0, 0) (
        customData = {
            string apiName = "torque"
        }
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled.
            For units see mode attribute. Range: (-inf, inf)"""
    )
    bool physxForce:worldFrameEnabled = 0 (
        customData = {
            string apiName = "worldFrameEnabled"
        }
        doc = """Boolean defining whether the force and torque are in world frame or in local frame."""
    )
}

class "PhysxSchemaPhysxIsosurfaceAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "IsosurfaceAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """Applied to a PhysxParticleSystem.
        Defines settings to extract an isosurface from the particles in the particle system."""
)
{
    float physxIsosurface:anisotropyMax = 2 (
        customData = {
            string apiName = "anisotropyMax"
        }
        doc = """The maximal scale anisotropy can apply to a particle radius.
            Range: [anisotropyMin, inf) Units: dimensionless"""
    )
    float physxIsosurface:anisotropyMin = 0.1 (
        customData = {
            string apiName = "anisotropyMin"
        }
        doc = """The minimal scale anisotropy can apply to a particle radius.
            Range: [0, anisotropyMax] Units: dimensionless"""
    )
    float physxIsosurface:anisotropyRadius = 0.5 (
        customData = {
            string apiName = "anisotropyRadius"
        }
        doc = """Radius that defines the size of the neighborhood used to determine the anisotropy information.
            Range: [0, inf) Units: distance"""
    )
    bool physxIsosurface:enableAnisotropy = 0 (
        customData = {
            string apiName = "enableAnisotropy"
        }
        doc = """Enables usage of anisotropy information during isosurface extraction process."""
    )
    string physxIsosurface:gridFilteringPasses = "GSRS" (
        customData = {
            string apiName = "gridFilteringPasses"
        }
        doc = """Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. 
        Up to 8 passes, every pass can consist of up to 4 repetitions."""
    )
    float physxIsosurface:gridSmoothingRadiusRelativeToCellSize = 0.5 (
        customData = {
            string apiName = "gridSmoothingRadiusRelativeToCellSize"
        }
        doc = """The radius used during the smoothing process on the grid.
        It is measured relative to the grid's cell size. Range: [0, inf) Units: dimensionless"""
    )
    float physxIsosurface:gridSpacing = 0.25 (
        customData = {
            string apiName = "gridSpacing"
        }
        doc = """Cell Size of the grid used for isosurface extraction.
        Range: (0, inf) Units: distance"""
    )
    bool physxIsosurface:isoSurfaceEnabled = 1 (
        customData = {
            string apiName = "isoSurfaceEnabled"
        }
        doc = """Enable or disable the creation of an isosurface."""
    )
    float physxIsosurface:isosurfaceLevel = -0.3 (
        customData = {
            string apiName = "isosurfaceLevel"
        }
        doc = """The level at which the isosurface is located.
        Allows to control the droplet size. The signed distance field is more negative towards the center of the fluid and positive outside. Range: (-inf, inf) Units: distance"""
    )
    float physxIsosurface:kernelRadius = 0.5 (
        customData = {
            string apiName = "kernelRadius"
        }
        doc = """Radius of the kernel used to transfer the density to the isosurface grid.
        Range: (0, inf) Units: distance"""
    )
    int physxIsosurface:maxSubgrids = 1024 (
        customData = {
            string apiName = "maxSubgrids"
        }
        doc = """Maximum number of blocks the sparse grid structure can contain.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxTriangles = 2097152 (
        customData = {
            string apiName = "maxTriangles"
        }
        doc = """Maximum number of triangles the extracted isosurface can have.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxVertices = 1048576 (
        customData = {
            string apiName = "maxVertices"
        }
        doc = """Maximum number of vertices the extracted isosurface can have.
        Range: [3, inf)"""
    )
    int physxIsosurface:numMeshSmoothingPasses = 2 (
        customData = {
            string apiName = "numMeshSmoothingPasses"
        }
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
        Using an even number of passes leads to less shrinking. Range: [0, inf)"""
    )
}

class "PhysxSchemaPhysxJointAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "JointAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX joint extended parameters."""
)
{
    float physxJoint:armature = 0 (
        customData = {
            string apiName = "armature"
        }
        doc = """Armature can help stabilize an articulation by adding to the inertial response of a joint.
        Conceptually, armature represents the inertia of an actuator driving the joint. Note that this parameter is used only when the joint belongs to an articulation. 
        Range: [0, inf) Units: Linear joint - mass Angular joint - mass * (distance)^2
        """
    )
    bool physxJoint:enableProjection = 0 (
        customData = {
            string apiName = "enableProjection"
        }
        doc = """Whether the actors should get projected for this constraint (the direction will be chosen by PhysX)."""
    )
    float physxJoint:jointFriction = 0 (
        customData = {
            string apiName = "jointFriction"
        }
        doc = """Joint friction.
        Only applies for joints that are parts of an articulation. Range: [0, inf) Units: dimensionless"""
    )
    float physxJoint:maxJointVelocity = 1000000 (
        customData = {
            string apiName = "maxJointVelocity"
        }
        doc = """Maximum joint velocity.
        Range: [0, inf) Units: Linear joint - distance / time Angular joint - degrees / time"""
    )
}

class "PhysxSchemaPhysxMaterialAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "MaterialAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX material extended parameters.
    For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. 
    So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    bool physxMaterial:compliantContactAccelerationSpring = 0 (
        customData = {
            string apiName = "compliantContactAccelerationSpring"
        }
        doc = """If enabled, switches from force-based to acceleration-based compliant spring-damper contact effects.
        An acceleration-based spring-damper directly influences the acceleration of (rather than the force on) the contacting bodies, 
        which makes the sink-in depth independent of the mass. The setting has no effect if compliant contacts are disabled, i.e., if the compliant contact stiffness is zero.
        """
    )
    float physxMaterial:compliantContactDamping = 0 (
        customData = {
            string apiName = "compliantContactDamping"
        }
        doc = """Damping coefficient for a compliant contact model using implicit springs.

        Ignored if compliant contacts are disabled (compliantContactStiffness is set to zero), in which case rigid contacts are active. 
        Depending on the compliantContactAccelerationSpring setting, the damping is interpreted as a force or acceleration, respectively, per unit velocity. 
        Range: [0, inf) Units (force spring): force / (distance / seconds) = mass / seconds Units (acceleration spring): acceleration / (distance / seconds) = 1 / seconds
        """
    )
    float physxMaterial:compliantContactStiffness = 0 (
        customData = {
            string apiName = "compliantContactStiffness"
        }
        doc = """Spring stiffness for a compliant contact model using implicit springs.

        A higher stiffness results in behavior closer to a rigid contact. The compliant contact model is only enabled if the stiffness is larger than 0. 
        Depending on the compliantContactAccelerationSpring setting, the stiffness is interpreted as a force or acceleration, respectively, per unit distance. 
        Range: [0, inf) Units (force spring): force/distance = mass / seconds / seconds Units (acceleration spring): acceleration/distance = 1 / seconds / seconds
        """
    )
    uniform token physxMaterial:dampingCombineMode = "average" (
        customData = {
            string apiName = "dampingCombineMode"
        }
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a damping coefficient for a collision.

        This value is only relevant for compliant contact interactions.
        """
    )
    uniform token physxMaterial:frictionCombineMode = "average" (
        customData = {
            string apiName = "frictionCombineMode"
        }
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a friction coefficient for a collision.
        """
    )
    uniform token physxMaterial:restitutionCombineMode = "average" (
        customData = {
            string apiName = "restitutionCombineMode"
        }
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a restitution coefficient for a collision.
        """
    )
}

class "PhysxSchemaPhysxMeshMergeCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "MeshMergeCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysxMeshMergeCollisionAPI enables implicit mesh merging of given meshes with respect to physics collision geometry representation.

    It is expected that this API extends the UsdPhysics.CollisionAPI definition, the UsdPhysics.CollisionAPI is still required to be present together with this API to define the collision properties. All meshes that belong to the collisionmeshes collection will be merged into one mesh that will be used for collision representation. Note that the collection can also define what meshes should be excluded from the selection.

    This means that for example all meshes that belong to the collection will be represented as one convexHull rather than dozens of convexHulls per mesh.

    It is possible to collect meshes through the collection that do not belong to the same hierarchy. This is allowed, however if the collisions are part of a rigid body, the meshes that do not belong to the rigid body hierarchy wont move. As defined in the rigid body specification, only rigid body transformation is updated.

    Note that any changes to the meshes during runtime will get ignored.
    """
)
{
}

class "PhysxSchemaPhysxMimicJointAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "MimicJointAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "physxMimicJoint"
    }
    doc = """Applied to a Physics Joint that must be part of an articulation.

    Supported joint types are: PhysicsRevoluteJoint (with a limit set), PhysicsPrismaticJoint as well as the more generic PhysicsJoint if all linear degrees of freedom are locked.

    This schema allows to interconnect the degrees of freedom of two joints according to the relationship: jointPosition + (gearing * referenceJointPosition) + offset = 0. This can be used to have, for example, one joint mimic the motion of another joint. The term "position" does not necessarily mean a translational unit, in the case of an angular degree of freedom it is an angle. The mimic joint operates on a single degree of freedom which is specified through the instance name of this multiple apply schema. The allowed instance name tokens are "rotX", "rotY" and "rotZ". See the documentation of the attribute referenceJointAxis for more info related to specifying the degree of freedom to operate on. Notes: 1) the two joints have to be part of the same articulation. 2) once the simulation has started, a significant performance penalty will be incurred if a mimic joint is added or removed, if the referenceJoint relationship is changed or if the referenceJointAxis attributes is modified. 3) the mimic joint relationship is interpreted as a two-way interaction and an impulse will get applied to the reference joint as well.

    For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    float gearing = 1 (
        customData = {
            string apiName = "gearing"
        }
        doc = """The gearing coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
        Range: (-inf, inf) Units: unitless or degrees/distance or distance/degrees (the last two refer to scenarios where a linear degree of freedom is connected to an angular one or vice versa)
        """
    )
    float offset = 0 (
        customData = {
            string apiName = "offset"
        }
        doc = """The offset coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
        Range: (-inf, inf) Units: distance or degrees (depending on whether the mimic joint's degree of freedom is linear or angular)
        """
    )
    uniform token referenceJointAxis = "rotX" (
        customData = {
            string apiName = "referenceJointAxis"
        }
        allowedTokens = ["rotX", "rotY", "rotZ"]
        doc = """
        The axis that marks the degree of freedom of the reference joint to mimic.

        Has to be a valid degree of freedom on the reference joint. For joint types with a single degree of freedom (like PhysicsRevoluteJoint or PhysicsPrismaticJoint), 
        this attribute will be ignored since the axis is defined implicitly. 
        The mimic joint connects <targetJoint, targetJointAxis> to <referenceJoint, referenceJointAxis> with targetJoint being the prim that has PhysxMimicJointAPI applied 
        and targetJointAxis being defined through the instance name token of PhysxMimicJointAPI.
        """
    )
}

class "PhysxSchemaPhysxPhysicsDistanceJointAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "PhysicsDistanceJointAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX distance joint extended parameters."""
)
{
    float physxPhysicsDistanceJoint:springDamping = 0 (
        customData = {
            string apiName = "springDamping"
        }
        doc = """Spring damping.
        Range: [0, inf) Units: force * seconds / distance = mass / seconds
        """
    )
    bool physxPhysicsDistanceJoint:springEnabled = 0 (
        customData = {
            string apiName = "springEnabled"
        }
        doc = """Whether spring should be enabled.
        (default off)
        """
    )
    float physxPhysicsDistanceJoint:springStiffness = 0 (
        customData = {
            string apiName = "springStiffness"
        }
        doc = """Spring stiffness.
        Range: [0, inf) Units: force / distance = mass / seconds^2
        """
    )
}

class PhysxSchemaPhysxPhysicsGearJoint "PhysxSchemaPhysxPhysicsGearJoint" (
    doc = """Predefined gear joint type."""
    # Inherits from </SimplePrim> defined in simple.usda.
    inherits = </PhysicsJoint>
    customData = {
        string className = "PhysicsGearJoint"
    }
)  {
    float physics:gearRatio = 1 (
        doc = """Gear ratio Range: (-inf, inf) Units: dimensionless."""
    )
    rel hinge0 (
        doc = "Relationship to first revolute joint."
    )
    rel hinge1 (
        doc = "Relationship to second revolute joint."
    )
}

class PhysxSchemaPhysxPhysicsRackAndPinionJoint "PhysxSchemaPhysxPhysicsRackAndPinionJoint" (
    doc = """Predefined rack & pinion joint type."""
    # Inherits from </SimplePrim> defined in simple.usda.
    inherits = </PhysicsJoint>
    customData = {
        string className = "PhysicsRackAndPinionJoint"
    }
)  {
    rel hinge (
        doc = "Relationship to revolute joint."
    )
    rel prismatic (
        doc = "Relationship to prismatic joint."
    )
    float physics:ratio = 1 (
        doc = """Ratio between angular and linear motion. 
        Range: (-inf, inf) Units: degrees / distance"""
    )
}

class PhysxSchemaPhysxPhysicsInstancer "PhysxSchemaPhysxPhysicsInstancer" (
    doc = """Core class for instancing physics prims."""
    # Inherits from </SimplePrim> defined in simple.usda.
    inherits = </Imageable>
    customData = {
        string className = "PhysicsInstancer"
    }
)  {
    int[] physics:protoIndices (
        doc = "Per-instance index into prototypes relationship that identifies what physics prims are instanced. Topology attribute - can be animated, but at a potential performance impact for streaming."
    )
}

class PhysxSchemaPhysxPhysicsJointInstancer "PhysxSchemaPhysxPhysicsJointInstancer" (
    doc = """Physics joint instancer, the prototypes are expected to be UsdPhysicsJoint prim types."""
    # Inherits from </SimplePrim> defined in simple.usda.
    inherits = </PhysxSchemaPhysxPhysicsInstancer>
    customData = {
        string className = "PhysicsJointInstancer"
    }
)  {
    int[] physics:body0Indices (
        doc = "**Optional property.** Only applicable if body0s is a point instancer. An index specifies the per-instance body0 rel as the rigid body at the body0s-instancer's protoIndices[index]."
    )
    rel physicsBody0s (
        doc = "**Required property.** The rel must contain either exactly one UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage. If the rel is to a point instancer, the body0Indices must be specified."
    )
    int[] physics:body1Indices (
        doc = "**Optional property.** Only applicable if body1s is a point instancer. An index specifies the per-instance body1 rel as the rigid body at the body1s-instancer's protoIndices[index]."
    )
    rel physicsBody1s (
        doc = "**Required property.** The rel must contain either exactly one UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage. If the rel is to a point instancer, the body0Indices must be specified."
    )
    point3f[] physics:localPos0s (
        doc = "**Required property.** Per-instance localPos0. This transformation is added on top of the joint localPos0."
    )
    point3f[] physics:localPos1s (
        doc = "**Required property.** Per-instance localPos1. This transformation is added on top of the joint localPos1."
    )
    quath[] physics:localRot0s (
        doc = "**Required property.** Per-instance localRot0. This transformation is added on top of the joint localPos0."
    )
    quath[] physics:localRot1s (
        doc = "**Required property.** Per-instance localRot1. This transformation is added on top of the joint localPos1."
    )
}

class "PhysxSchemaPhysxResidualReportingAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "ResidualReportingAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """
        Gives access to residual values that inform about the remaining physics solver error present during the last position and during the last velocity iteration.

        The residual reporting must be enabled on the Physics Scene, otherwise the reported values will be zero. The API can be applied to either:

        Joints. The joint residual will be reported.
        Articulation Roots. The RMS (root mean squared) and max value over all articulation joint residuals will be reported.
        Physics Scene. The RMS and max value over all error/residual sources (including contacts) will be reported.
    """
)
{
    float physxResidualReporting:maxResidualPositionIteration = 0 (
        customData = {
            string apiName = "maxResidualPositionIteration"
        }
        doc = """The maximal magnitude of the physics solver error during the last position iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxResidualReporting:maxResidualVelocityIteration = 0 (
        customData = {
            string apiName = "maxResidualVelocityIteration"
        }
        doc = """The maximal magnitude of the physics solver error during the last velocity iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxResidualReporting:rmsResidualPositionIteration = 0 (
        customData = {
            string apiName = "rmsResidualPositionIteration"
        }
        doc = """The RMS (root mean squared) magnitude of the physics solver error during the last position iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxResidualReporting:rmsResidualVelocityIteration = 0 (
        customData = {
            string apiName = "rmsResidualVelocityIteration"
        }
        doc = """The RMS (root mean squared) magnitude of the physics solver error during the last velocity iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
}

class "PhysxSchemaPhysxRigidBodyAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "RigidBodyAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """
        PhysX rigid body extended parameters.
    """
)
{
    float physxRigidBody:angularDamping = 0.05 (
        customData = {
            string apiName = "angularDamping"
        }
        doc = """Angular damping coefficient.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxRigidBody:cfmScale = 0.025 (
        customData = {
            string apiName = "cfmScale"
        }
        doc = """The cfm scale term can help stabilize an articulation by weakening the constraint's response.
        Use small values close to the default and typically in the range [0, 0.1] for best results. 
        Note that this parameter is currently used only if rigid body is part of an articulation. Range: [0, 1] Units: unitless
        """
    )
    float physxRigidBody:contactSlopCoefficient = 0 (
        customData = {
            string apiName = "contactSlopCoefficient"
        }
        doc = """Tolerance on the angular influence of a contact that can help improve the behavior of rolling approximate collision shapes.
        Specifically, the angular component of a normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. 
        The tolerance is scaled such that the behavior improvement persists through a range of angular velocities of a rolling shape. Range: [0, inf) Units: distance
        """
    )
    bool physxRigidBody:disableGravity = 0 (
        customData = {
            string apiName = "disableGravity"
        }
        doc = """Disable gravity for the actor.
        """
    )
    bool physxRigidBody:enableCCD = 0 (
        customData = {
            string apiName = "enableCCD"
        }
        doc = """Enables swept integration for the actor.
        """
    )
    bool physxRigidBody:enableGyroscopicForces = 1 (
        customData = {
            string apiName = "enableGyroscopicForces"
        }
        doc = """Enables computation of gyroscopic forces on the rigid body.
        """
    )
    bool physxRigidBody:enableSpeculativeCCD = 0 (
        customData = {
            string apiName = "enableSpeculativeCCD"
        }
        doc = """Register a rigid body to dynamically adjust contact offset based on velocity.
        This can be used to achieve a CCD effect.
        """
    )
    float physxRigidBody:linearDamping = 0 (
        customData = {
            string apiName = "linearDamping"
        }
        doc = """Linear damping coefficient.
        Range: [0, inf) Units: dimensionless
        """
    )
    int physxRigidBody:lockedPosAxis = 0 (
        customData = {
            string apiName = "lockedPosAxis"
        }
        doc = """Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2).
        """
    )
    int physxRigidBody:lockedRotAxis = 0 (
        customData = {
            string apiName = "lockedRotAxis"
        }
        doc = """Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2).
        """
    )
    float physxRigidBody:maxAngularVelocity = 5729.58 (
        customData = {
            string apiName = "maxAngularVelocity"
        }
        doc = """Maximum allowable angular velocity for rigid body.
        Range: [0, inf) Units: degrees / seconds
        """
    )
    float physxRigidBody:maxContactImpulse = inf (
        customData = {
            string apiName = "maxContactImpulse"
        }
        doc = """Sets a limit on the impulse that may be applied at a contact.
        The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. 
        For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body. Range: [0, inf) Units: force * seconds = mass * distance / seconds
        """
    )
    float physxRigidBody:maxDepenetrationVelocity = 3 (
        customData = {
            string apiName = "maxDepenetrationVelocity"
        }
        doc = """The maximum depenetration velocity permitted to be introduced by the solver.
        Range: [0, inf) Default: 5.0 * tolerancesLength Units: distance / seconds
        """
    )
    float physxRigidBody:maxLinearVelocity = inf (
        customData = {
            string apiName = "maxLinearVelocity"
        }
        doc = """Maximum allowable linear velocity for the rigid body.
        Range: [0, inf) Units: distance / seconds
        """
    )
    bool physxRigidBody:retainAccelerations = 0 (
        customData = {
            string apiName = "retainAccelerations"
        }
        doc = """Carries over forces/accelerations between frames, rather than clearing them.
        """
    )
    float physxRigidBody:sleepThreshold = 0.00005 (
        customData = {
            string apiName = "sleepThreshold"
        }
        doc = """Mass-normalized kinetic energy threshold below which an actor may go to sleep.
        Range: [0, inf) Default: 0.00005 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds
        """
    )
    bool physxRigidBody:solveContact = 1 (
        customData = {
            string apiName = "solveContact"
        }
        doc = """Process the contacts of this rigid body in the dynamics solver.
        """
    )
    int physxRigidBody:solverPositionIterationCount = 16 (
        customData = {
            string apiName = "solverPositionIterationCount"
        }
        doc = """Solver position iteration counts for the body.
        Allowed range [1, 255].
        """
    )
    int physxRigidBody:solverVelocityIterationCount = 1 (
        customData = {
            string apiName = "solverVelocityIterationCount"
        }
        doc = """Solver velocity iteration counts for the body.
        Allowed range [0, 255].
        """
    )
    float physxRigidBody:stabilizationThreshold = 0.00001 (
        customData = {
            string apiName = "stabilizationThreshold"
        }
        doc = """Mass-normalized kinetic energy threshold below which an actor may participate in stabilization.
        Range: [0, inf) Default: 0.00001 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds
        """
    )
}

class "PhysxSchemaPhysxSceneAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "SceneAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """
        PhysX scene extended parameters.

        Default PhysX material for the scene can be set by using material bind with purpose physics onto the PhysicsScene prim.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    float physxScene:bounceThreshold = 0 (
        customData = {
            string apiName = "bounceThreshold"
        }
        doc = """A contact with a relative velocity below this will not bounce.
        Range: [0, inf) Default: 0 Units: distance / seconds
        """
    )
    uniform token physxScene:broadphaseType = "GPU" (
        customData = {
            string apiName = "broadphaseType"
        }
        allowedTokens = ["GPU", "MBP", "SAP"]
        doc = """Broad phase algorithm used in the simulation."""
    )
    uniform token physxScene:collisionSystem = "PCM" (
        customData = {
            string apiName = "collisionSystem"
        }
        allowedTokens = ["PCM", "SAT"]
        doc = """Collision detection system."""
    )
    bool physxScene:enableCCD = 0 (
        customData = {
            string apiName = "enableCCD"
        }
        doc = """Enables a second broad phase check after integration that makes it possible to prevent objects from tunneling through each other.
        """
    )
    bool physxScene:enableEnhancedDeterminism = 0 (
        customData = {
            string apiName = "enableEnhancedDeterminism"
        }
        doc = """Provides improved determinism at the expense of performance.
        """
    )
    bool physxScene:enableExternalForcesEveryIteration = 0 (
        customData = {
            string apiName = "enableExternalForcesEveryIteration"
        }
        doc = """Enables greater TGS solver stability.
        """
    )
    bool physxScene:enableGPUDynamics = 1 (
        customData = {
            string apiName = "enableGPUDynamics"
        }
        doc = """Enables the GPU dynamics pipeline.

        Required for GPU only features like deformables.
        """
    )
    bool physxScene:enableResidualReporting = 0 (
        customData = {
            string apiName = "enableResidualReporting"
        }
        doc = """Calculates solver residuals and reports them through optional Residual Report APIs at a slight expense of performance.
        """
    )
    bool physxScene:enableSceneQuerySupport = 1 (
        customData = {
            string apiName = "enableSceneQuerySupport"
        }
        doc = """Enables scene query support for collision shapes.
        """
    )
    bool physxScene:enableStabilization = 0 (
        customData = {
            string apiName = "enableStabilization"
        }
        doc = """Enables additional stabilization pass in solver.
        """
    )
    float physxScene:frictionCorrelationDistance = 0.025 (
        customData = {
            string apiName = "frictionCorrelationDistance"
        }
        doc = """Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not.
        Range: [0, inf) Default: 0.025 * tolerancesLength Units: distance
        """
    )
    float physxScene:frictionOffsetThreshold = 0.04 (
        customData = {
            string apiName = "frictionOffsetThreshold"
        }
        doc = """A threshold of contact separation distance used to decide if a contact point will experience friction forces.
        Range: [0, inf) Default: 0.04 * tolerancesLength Units: distance
        """
    )
    uniform token physxScene:frictionType = "patch" (
        customData = {
            string apiName = "frictionType"
        }
        allowedTokens = ["patch"]
        doc = """Friction type used in simulation."""
    )
    uint physxScene:gpuCollisionStackSize = 67108864 (
        customData = {
            string apiName = "gpuCollisionStackSize"
        }
        doc = """Gpu collision stack size.
        """
    )
    uint physxScene:gpuFoundLostAggregatePairsCapacity = 1024 (
        customData = {
            string apiName = "gpuFoundLostAggregatePairsCapacity"
        }
        doc = """Gpu found lost aggregate pairs capacity.
        """
    )
    uint physxScene:gpuFoundLostPairsCapacity = 262144 (
        customData = {
            string apiName = "gpuFoundLostPairsCapacity"
        }
        doc = """Gpu found lost pairs capacity.
        """
    )
    uint physxScene:gpuHeapCapacity = 67108864 (
        customData = {
            string apiName = "gpuHeapCapacity"
        }
        doc = """Gpu heap capacity.
        """
    )
    uint physxScene:gpuMaxDeformableSurfaceContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxDeformableSurfaceContacts"
        }
        doc = """Gpu max deformable surface contacts.
        """
    )
    uint physxScene:gpuMaxHairContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxHairContacts"
        }
        doc = """Gpu max hair contacts.
        """
    )
    uint physxScene:gpuMaxNumPartitions = 8 (
        customData = {
            string apiName = "gpuMaxNumPartitions"
        }
        doc = """Limitation for the partitions in the GPU dynamics pipeline.
        This variable must be a power of 2. A value greater than 32 is currently not supported.
        """
    )
    uint physxScene:gpuMaxParticleContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxParticleContacts"
        }
        doc = """Gpu max particle contacts.
        """
    )
    uint physxScene:gpuMaxRigidContactCount = 524288 (
        customData = {
            string apiName = "gpuMaxRigidContactCount"
        }
        doc = """Gpu max rigid contact count.
        """
    )
    uint physxScene:gpuMaxRigidPatchCount = 81920 (
        customData = {
            string apiName = "gpuMaxRigidPatchCount"
        }
        doc = """Gpu max rigid patch count.
        """
    )
    uint physxScene:gpuMaxSoftBodyContacts = 1048576 (
        customData = {
            string apiName = "gpuMaxSoftBodyContacts"
        }
        doc = """Gpu max soft body contacts.
        """
    )
    uint64 physxScene:gpuTempBufferCapacity = 16777216 (
        customData = {
            string apiName = "gpuTempBufferCapacity"
        }
        doc = """Gpu temp buffer capacity.
        """
    )
    uint physxScene:gpuTotalAggregatePairsCapacity = 1024 (
        customData = {
            string apiName = "gpuTotalAggregatePairsCapacity"
        }
        doc = """Gpu total aggregate pairs capacity.
        """
    )
    bool physxScene:invertCollisionGroupFilter = 0 (
        customData = {
            string apiName = "invertCollisionGroupFilter"
        }
        doc = """Boolean attribute indicating whether inverted collision group filtering should be used.

        By default two collisions, that do have a collisionGroup set, collide with each other. 
        Adding a collisionGroup into a collisionGroup filtering will mean that the collision between those groups will be disabled. 
        This boolean attribute does invert the default behavior. Hence two collisions with defined collisionGroups will not collide with each other by default 
        and one does enable the collisions between the groups through the "CollisionGroup" filtering.
        """
    )
    float physxScene:maxBiasCoefficient = inf (
        customData = {
            string apiName = "maxBiasCoefficient"
        }
        doc = """The maximum bias coefficient used in the constraint solver.
        Range: [0, inf) Units: dimensionless
        """
    )
    uniform uint physxScene:maxPositionIterationCount = 255 (
        customData = {
            string apiName = "maxPositionIterationCount"
        }
        doc = """Maximum position iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations. Range: [1, 255]"""
    )
    uniform uint physxScene:maxVelocityIterationCount = 255 (
        customData = {
            string apiName = "maxVelocityIterationCount"
        }
        doc = """Maximum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations. Range: [0, 255]"""
    )
    uniform uint physxScene:minPositionIterationCount = 1 (
        customData = {
            string apiName = "minPositionIterationCount"
        }
        doc = """Minimum position iteration count for all actors (rigid bodies, cloth, particles etc).
        Range: [1, 255]"""
    )
    uniform uint physxScene:minVelocityIterationCount = 0 (
        customData = {
            string apiName = "minVelocityIterationCount"
        }
        doc = """Minimum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
        Range: [0, 255]"""
    )
    bool physxScene:reportKinematicKinematicPairs = 0 (
        customData = {
            string apiName = "reportKinematicKinematicPairs"
        }
        doc = """Boolean attribute indicating whether kinematic vs kinematic pairs generate contact reports.
        """
    )
    bool physxScene:reportKinematicStaticPairs = 0 (
        customData = {
            string apiName = "reportKinematicStaticPairs"
        }
        doc = """Boolean attribute indicating whether kinematic vs static pairs generate contact reports.
        """
    )
    uniform token physxScene:solverType = "TGS" (
        customData = {
            string apiName = "solverType"
        }
        allowedTokens = ["TGS", "PGS"]
        doc = """Solver used for the simulation."""
    )
    uint physxScene:timeStepsPerSecond = 60 (
        customData = {
            string apiName = "timeStepsPerSecond"
        }
        doc = """Simulation scene step defined as number of steps per second.
        Note that application might cap the number of simulation steps to avoid running more simulations steps with a low frame rate.
        """
    )
    uniform token physxScene:updateType = "Synchronous" (
        customData = {
            string apiName = "updateType"
        }
        allowedTokens = ["Synchronous", "Asynchronous", "Disabled"]
        doc = """Type of update for a PhysX scene."""
    )
}