#usda 1.0
(
    subLayers = [
        @usdGeom/schema.usda@
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName       = "usdPhysX"
        string libraryPath       = "pxr/usd/usdPhysX"
        string libraryPrefix     = "UsdPhysX"
    }
) {
}

class "PhysxSchemaJointStateAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "JointStateAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "jointState"
    }
    doc = """The PhysicsJointStateAPI is applied to a joint primitive (i.e. any PhysicsJoint-derived type)
    and provides read/write access to the joint position and velocity for a specific joint axis.
    The PhysicsJointStateAPI is a multipleApply schema, and its instance name TfToken defines the joint axis:
    The name can be "transX", "transY", "transZ", "rotX", "rotY", "rotZ"
    or its "linear" for prismatic joint or "angular" for revolute joints, respectively.
"""
)
{
    float physics:position (
        customData = {
            string apiName = "position"
        }
        doc = """Joint state position defines the relative difference between joint body0 frame and joint body1 frame in world frame.
               Range: (-inf, inf) Units: linear - distance angular - degrees"""
    )
    float physics:velocity (
        customData = {
            string apiName = "velocity"
        }
        doc = """Joint state velocity defines the relative velocity between joint body0 and joint body1.
               Range: (-inf, inf) Units: linear - distance / seconds angular - degrees / seconds"""
    )
}

class "PhysxSchemaPhysxArticulationAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxArticulationAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX articulation extended parameters."""
)
{
    bool physxArticulation:articulationEnabled = 1 (
        customData = {
            string apiName = "articulationEnabled"
        }
        doc = """Boolean defining whether articulation is enabled or disabled."""
    )
    bool physxArticulation:enabledSelfCollisions = 1 (
        customData = {
            string apiName = "enabledSelfCollisions"
        }
        doc = """Boolean defining whether self collisions should be enabled or disabled."""
    )
    float physxArticulation:sleepThreshold = 0.00005 (
        customData = {
            string apiName = "sleepThreshold"
        }
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf) Default: 0.00005 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
    int physxArticulation:solverPositionIterationCount = 32 (
        customData = {
            string apiName = "solverPositionIterationCount"
        }
        doc = """Solver position iteration counts for the body.
            Allowed range [1, 255]."""
    )
    int physxArticulation:solverVelocityIterationCount = 1 (
        customData = {
            string apiName = "solverVelocityIterationCount"
        }
        doc = """Solver velocity iteration counts for the body.
            Allowed range [0, 255]."""
    )
    float physxArticulation:stabilizationThreshold = 0.00001 (
        customData = {
            string apiName = "stabilizationThreshold"
        }
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf) Default: 0.00001 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxSchemaPhysxCameraAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCameraAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera."""
)
{
    bool alwaysUpdateEnabled = 1 (
        customData = {
            string apiName = "alwaysUpdateEnabled"
        }
        doc = """When enabled, always update this camera whether it is the active camera or not.
            This prevents cameras from slewing into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
}

class "PhysxSchemaPhysxCameraDroneAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCameraDroneAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX drone camera that follows its subject from the air as it drives."""
)
{
    float physxDroneCamera:feedForwardVelocityGain (
        customData = {
            string apiName = "feedForwardVelocityGain"
        }
        doc = """The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"""
    )
    float physxDroneCamera:followDistance (
        customData = {
            string apiName = "followDistance"
        }
        doc = """The distance from the subject that the drone attempts to maintain. e.g. 30 meters"""
    )
    float physxDroneCamera:followHeight (
        customData = {
            string apiName = "followHeight"
        }
        doc = """The height above the subject that the drone attmepts to maintain. e.g. 15 meters"""
    )
    float physxDroneCamera:horizontalVelocityGain (
        customData = {
            string apiName = "horizontalVelocityGain"
        }
        doc = """The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"""
    )
    float physxDroneCamera:maxDistance (
        customData = {
            string apiName = "maxDistance"
        }
        doc = """The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"""
    )
    float physxDroneCamera:maxSpeed (
        customData = {
            string apiName = "maxSpeed"
        }
        doc = """The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"""
    )
    float3 physxDroneCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        doc = """An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"""
    )
    float physxDroneCamera:rotationFilterTimeConstant (
        customData = {
            string apiName = "rotationFilterTimeConstant"
        }
        doc = """The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"""
    )
    float physxDroneCamera:velocityFilterTimeConstant (
        customData = {
            string apiName = "velocityFilterTimeConstant"
        }
        doc = """The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"""
    )
    float physxDroneCamera:verticalVelocityGain (
        customData = {
            string apiName = "verticalVelocityGain"
        }
        doc = """The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"""
    )
}

class "PhysxSchemaPhysxCameraFollowAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCameraFollowAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject as it moves."""
)
{
    float3 physxFollowCamera:cameraPositionTimeConstant (
        customData = {
            string apiName = "cameraPositionTimeConstant"
        }
        doc = """Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"""
    )
    float physxFollowCamera:followMaxDistance (
        customData = {
            string apiName = "followMaxDistance"
        }
        doc = """The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"""
    )
    float physxFollowCamera:followMaxSpeed (
        customData = {
            string apiName = "followMaxSpeed"
        }
        doc = """The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"""
    )
    float physxFollowCamera:followMinDistance (
        customData = {
            string apiName = "followMinDistance"
        }
        doc = """The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"""
    )
    float physxFollowCamera:followMinSpeed (
        customData = {
            string apiName = "followMinSpeed"
        }
        doc = """The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"""
    )
    float physxFollowCamera:followTurnRateGain (
        customData = {
            string apiName = "followTurnRateGain"
        }
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject.
            Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowFollowCamera:lookAheadMaxDistance (
        customData = {
            string apiName = "lookAheadMaxDistance"
        }
        doc = """The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 500.0 cm"""
    )
    float physxFollowCamera:lookAheadMaxSpeed (
        customData = {
            string apiName = "lookAheadMaxSpeed"
        }
        doc = """The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"""
    )
    float physxFollowCamera:lookAheadMinDistance (
        customData = {
            string apiName = "lookAheadMinDistance"
        }
        doc = """The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"""
    )
    float physxFollowCamera:lookAheadMinSpeed (
        customData = {
            string apiName = "lookAheadMinSpeed"
        }
        doc = """The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"""
    )
    float physxFollowCamera:lookAheadTurnRateGain (
        customData = {
            string apiName = "lookAheadTurnRateGain"
        }
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowCamera:lookPositionHeight (
        customData = {
            string apiName = "lookPositionHeight"
        }
        doc = """Distance to elevate the camera look point. e.g. 50.0 cm"""
    )
    float3 physxFollowCamera:lookPositionTimeConstant (
        customData = {
            string apiName = "lookPositionTimeConstant"
        }
        doc = """Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"""
    )
    float physxFollowCamera:pitchAngle (
        customData = {
            string apiName = "pitchAngle"
        }
        doc = """The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"""
    )
    float physxFollowCamera:pitchAngleTimeConstant (
        customData = {
            string apiName = "pitchAngleTimeConstant"
        }
        doc = """Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"""
    )
    float3 physxFollowCamera:positionOffset (
        customData = {
            string apiName = "positionOffset"
        }
        doc = """Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"""
    )
    float physxFollowCamera:slowPitchAngleSpeed (
        customData = {
            string apiName = "slowPitchAngleSpeed"
        }
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"""
    )
    float physxFollowCamera:slowSpeedPitchAngleScale (
        customData = {
            string apiName = "slowSpeedPitchAngleScale"
        }
        doc = """Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"""
    )
    float physxFollowCamera:velocityNormalMinSpeed (
        customData = {
            string apiName = "velocityNormalMinSpeed"
        }
        doc = """The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"""
    )
    float physxFollowCamera:yawAngle (
        customData = {
            string apiName = "yawAngle"
        }
        doc = """The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"""
    )
    float physxFollowCamera:yawRateTimeConstant (
        customData = {
            string apiName = "yawRateTimeConstant"
        }
        doc = """Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"""
    )
}

class "PhysxSchemaPhysxCameraFollowLookAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCameraFollowLookAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject's forward vector as it moves.
        Assumes the subject is always upright and does not roll."""
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        customData = {
            string apiName = "downHillGroundAngle"
        }
        doc = """The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"""
    )
    float physxFollowLookCamera:downHillGroundPitch (
        customData = {
            string apiName = "downHillGroundPitch"
        }
        doc = """The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )
    float physxFollowLookCamera:followReverseDistance (
        customData = {
            string apiName = "followReverseDistance"
        }
        doc = """The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"""
    )
    float physxFollowLookCamera:followReverseSpeed (
        customData = {
            string apiName = "followReverseSpeed"
        }
        doc = """The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"""
    )
    float physxFollowLookCamera:upHillGroundAngle (
        customData = {
            string apiName = "upHillGroundAngle"
        }
        doc = """The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"""
    )
    float physxFollowLookCamera:upHillGroundPitch (
        customData = {
            string apiName = "upHillGroundPitch"
        }
        doc = """The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"""
    )
    float physxFollowLookCamera:velocityBlendTimeConstant (
        customData = {
            string apiName = "velocityBlendTimeConstant"
        }
        doc = """Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"""
    )
}

class "PhysxSchemaPhysxCameraFollowVelocityAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCameraFollowVelocityAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."""
)
{
}

class "PhysxSchemaPhysxCharacterControllerAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCharacterControllerAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysxCharacterControllerAPI can be applied to a capsuleGeom.
        It will turn the capsule into a character controller.
        For any described attribute Fallback Value or Allowed Values below that are text/tokens, 
        the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value."""
)
{
    uniform token physxCharacterController:climbingMode = "easy" (
        customData = {
            string apiName = "climbingMode"
        }
        allowedTokens = ["easy", "constrained"]
        doc = """The climbing mode."""
    )
    float physxCharacterController:contactOffset = 0.1 (
        customData = {
            string apiName = "contactOffset"
        }
        doc = """The contact offset used by the controller. Range: [0, inf) Units: distance"""
    )
    float physxCharacterController:invisibleWallHeight = 0 (
        customData = {
            string apiName = "invisibleWallHeight"
        }
        doc = """Height of invisible walls created around non-walkable triangles. Range: [0, inf) Units: distance"""
    )
    float physxCharacterController:maxJumpHeight = 0 (
        customData = {
            string apiName = "maxJumpHeight"
        }
        doc = """Maximum height a jumping character can reach. Range: [0, inf) Units: distance"""
    )
    vector3f physxCharacterController:moveTarget = (0, 0, 0) (
        customData = {
            string apiName = "moveTarget"
        }
        doc = """Desired target position that CCT should try to reach."""
    )
    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        customData = {
            string apiName = "nonWalkableMode"
        }
        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        doc = """The non-walkable mode controls if a character controller slides or not on a non-walkable part."""
    )
    float physxCharacterController:scaleCoeff = 0.8 (
        customData = {
            string apiName = "scaleCoeff"
        }
        doc = """Scale coefficient for underlying kinematic actor. Range: [0, inf) Units: dimensionless"""
    )
    float physxCharacterController:slopeLimit = 0.3 (
        customData = {
            string apiName = "slopeLimit"
        }
        doc = """Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. A value of 0 disables this feature."""
    )
    float physxCharacterController:stepOffset = 0.5 (
        customData = {
            string apiName = "stepOffset"
        }
        doc = """Defines the maximum height of an obstacle which the character can climb. Range: [0, inf) Units: distance"""
    )
    uniform token physxCharacterController:upAxis = "Z" (
        customData = {
            string apiName = "upAxis"
        }
        allowedTokens = ["X", "Y", "Z"]
        doc = """Up axis for stepping functionality."""
    )
    float physxCharacterController:volumeGrowth = 1.5 (
        customData = {
            string apiName = "volumeGrowth"
        }
        doc = """Cached volume growth. Range: [0, inf) Units: dimensionless"""
    )
}

class "PhysxSchemaPhysxCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX collision extended parameters."""
)
{
    float physxCollision:contactOffset = -inf (
        customData = {
            string apiName = "contactOffset"
        }
        doc = """Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent. Range: [maximum(0, restOffset), inf) Units: distance"""
    )
    float physxCollision:minTorsionalPatchRadius = 0 (
        customData = {
            string apiName = "minTorsionalPatchRadius"
        }
        doc = """Defines the minimum radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"""
    )
    float physxCollision:restOffset = -inf (
        customData = {
            string apiName = "restOffset"
        }
        doc = """Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value. For rigid bodies, this value is zero. Range: [0, contactOffset] Units: distance"""
    )
    float physxCollision:torsionalPatchRadius = 0 (
        customData = {
            string apiName = "torsionalPatchRadius"
        }
        doc = """Defines the radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"""
    )
}

class "PhysxSchemaPhysxContactReportAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxContactReportAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """Enables contact reporting for a rigid body or articulation."""
)
{
    float physxContactReport:threshold = 1 (
        customData = {
            string apiName = "threshold"
        }
        doc = """Sets the force threshold for contact reports. Range: [0, inf] Units: force = mass * distance / seconds^2"""
    )
}

class "PhysxSchemaPhysxConvexDecompositionCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxConvexDecompositionCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX convex decomposition(VHACD) extended parameters."""
)
{
    float physxConvexDecompositionCollision:errorPercentage = 10 (
        customData = {
            string apiName = "errorPercentage"
        }
        doc = """Convex decomposition errorPercentage parameter."""
    )
    int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }
        doc = """Convex hull vertex limit used for convex hull cooking."""
    )
    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        customData = {
            string apiName = "maxConvexHulls"
        }
        doc = """Maximum of convex hulls created during convex decomposition."""
    )
    float physxConvexDecompositionCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }
        doc = """Convex hull min thickness. Range: [0, inf) Units: distance"""
    )
    bool physxConvexDecompositionCollision:shrinkWrap = 0 (
        customData = {
            string apiName = "shrinkWrap"
        }
        doc = """Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."""
    )
    int physxConvexDecompositionCollision:voxelResolution = 500000 (
        customData = {
            string apiName = "voxelResolution"
        }
        doc = """Voxel resolution used for convex decomposition."""
    )
}

class "PhysxSchemaPhysxConvexHullCollisionAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxConvexHullCollisionAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """PhysX convex hull collision extended parameters."""
)
{
    int physxConvexHullCollision:hullVertexLimit = 64 (
        customData = {
            string apiName = "hullVertexLimit"
        }
        doc = """Convex hull vertex limit used for convex hull cooking."""
    )
    float physxConvexHullCollision:minThickness = 0.001 (
        customData = {
            string apiName = "minThickness"
        }
        doc = """Convex hull minimum thickness. Range: [0, inf) Units: distance"""
    )
}

class "PhysxSchemaPhysxCookedDataAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxCookedDataAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "physxCookedData"
    }
    doc = """PhysX cooked data storage."""
)
{
    uchar[] buffer (
        customData = {
            string apiName = "buffer"
        }
        doc = """CookedData"""
    )
}

class "PhysxSchemaPhysxForceAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxForceAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """
        PhysX schema API that applies a force and torque to a rigid body (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI).

        The API can be applied to either:

        The rigid-body Xformable, in which case the force is applied at the body's center of mass.
        To an UsdGeom.Xformable that is a child of the rigid-body Xformable, in which case the force is applied at the location defined by the Xformable.
        The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. Note that any scale transform operations will only affect the force and torque values if on "acceleration" mode.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    vector3f physxForce:force = (0, 0, 0) (
        customData = {
            string apiName = "force"
        }
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled.

        The force is applied at the position defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied directly to a rigid-body Xformable. For units see mode attribute. Range: (-inf, inf)
    """
    )
    bool physxForce:forceEnabled = 1 (
        customData = {
            string apiName = "forceEnabled"
        }
        doc = """Boolean defining whether the force and torque are enabled or disabled."""
    )
    uniform token physxForce:mode = "acceleration" (
        customData = {
            string apiName = "mode"
        }
        allowedTokens = ["acceleration", "force"]
        doc = """
        Force mode, can be either a force or an acceleration.

        force - units: (linear) mass * distance / seconds^2, i.e. a force (angular) mass * distance * distance / time^2, 
        i.e. a torque acceleration - units: (linear) distance / seconds^2, i.e. a linear acceleration. (angular) degrees / seconds^2, i.e. an angular acceleration.
        """
    )
    vector3f physxForce:torque = (0, 0, 0) (
        customData = {
            string apiName = "torque"
        }
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled.
            For units see mode attribute. Range: (-inf, inf)"""
    )
    bool physxForce:worldFrameEnabled = 0 (
        customData = {
            string apiName = "worldFrameEnabled"
        }
        doc = """Boolean defining whether the force and torque are in world frame or in local frame."""
    )
}

class "PhysxSchemaPhysxIsosurfaceAPI" (
    inherits = </APISchemaBase>
    customData = {
        string className = "physxIsosurfaceAPI"
        token apiSchemaType = "singleApply"
    }
    doc = """Applied to a PhysxParticleSystem.
        Defines settings to extract an isosurface from the particles in the particle system."""
)
{
    float physxIsosurface:anisotropyMax = 2 (
        customData = {
            string apiName = "anisotropyMax"
        }
        doc = """The maximal scale anisotropy can apply to a particle radius.
            Range: [anisotropyMin, inf) Units: dimensionless"""
    )
    float physxIsosurface:anisotropyMin = 0.1 (
        customData = {
            string apiName = "anisotropyMin"
        }
        doc = """The minimal scale anisotropy can apply to a particle radius.
            Range: [0, anisotropyMax] Units: dimensionless"""
    )
    float physxIsosurface:anisotropyRadius = 0.5 (
        customData = {
            string apiName = "anisotropyRadius"
        }
        doc = """Radius that defines the size of the neighborhood used to determine the anisotropy information.
            Range: [0, inf) Units: distance"""
    )
    bool physxIsosurface:enableAnisotropy = 0 (
        customData = {
            string apiName = "enableAnisotropy"
        }
        doc = """Enables usage of anisotropy information during isosurface extraction process."""
    )
    string physxIsosurface:gridFilteringPasses = "GSRS" (
        customData = {
            string apiName = "gridFilteringPasses"
        }
        doc = """Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. 
        Up to 8 passes, every pass can consist of up to 4 repetitions."""
    )
    float physxIsosurface:gridSmoothingRadiusRelativeToCellSize = 0.5 (
        customData = {
            string apiName = "gridSmoothingRadiusRelativeToCellSize"
        }
        doc = """The radius used during the smoothing process on the grid.
        It is measured relative to the grid's cell size. Range: [0, inf) Units: dimensionless"""
    )
    float physxIsosurface:gridSpacing = 0.25 (
        customData = {
            string apiName = "gridSpacing"
        }
        doc = """Cell Size of the grid used for isosurface extraction.
        Range: (0, inf) Units: distance"""
    )
    bool physxIsosurface:isoSurfaceEnabled = 1 (
        customData = {
            string apiName = "isoSurfaceEnabled"
        }
        doc = """Enable or disable the creation of an isosurface."""
    )
    float physxIsosurface:isosurfaceLevel = -0.3 (
        customData = {
            string apiName = "isosurfaceLevel"
        }
        doc = """The level at which the isosurface is located.
        Allows to control the droplet size. The signed distance field is more negative towards the center of the fluid and positive outside. Range: (-inf, inf) Units: distance"""
    )
    float physxIsosurface:kernelRadius = 0.5 (
        customData = {
            string apiName = "kernelRadius"
        }
        doc = """Radius of the kernel used to transfer the density to the isosurface grid.
        Range: (0, inf) Units: distance"""
    )
    int physxIsosurface:maxSubgrids = 1024 (
        customData = {
            string apiName = "maxSubgrids"
        }
        doc = """Maximum number of blocks the sparse grid structure can contain.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxTriangles = 2097152 (
        customData = {
            string apiName = "maxTriangles"
        }
        doc = """Maximum number of triangles the extracted isosurface can have.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxVertices = 1048576 (
        customData = {
            string apiName = "maxVertices"
        }
        doc = """Maximum number of vertices the extracted isosurface can have.
        Range: [3, inf)"""
    )
    int physxIsosurface:numMeshSmoothingPasses = 2 (
        customData = {
            string apiName = "numMeshSmoothingPasses"
        }
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
        Using an even number of passes leads to less shrinking. Range: [0, inf)"""
    )
}