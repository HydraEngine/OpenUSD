#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "PhysxSchemaJointStateAPI" (
    doc = '''The PhysicsJointStateAPI is applied to a joint primitive (i.e. any PhysicsJoint-derived type)
    and provides read/write access to the joint position and velocity for a specific joint axis.
    The PhysicsJointStateAPI is a multipleApply schema, and its instance name TfToken defines the joint axis:
    The name can be "transX", "transY", "transZ", "rotX", "rotY", "rotZ"
    or its "linear" for prismatic joint or "angular" for revolute joints, respectively.
'''
)
{
    float jointState:__INSTANCE_NAME__:physics:position (
        doc = """Joint state position defines the relative difference between joint body0 frame and joint body1 frame in world frame.
               Range: (-inf, inf) Units: linear - distance angular - degrees"""
    )
    float jointState:__INSTANCE_NAME__:physics:velocity (
        doc = """Joint state velocity defines the relative velocity between joint body0 and joint body1.
               Range: (-inf, inf) Units: linear - distance / seconds angular - degrees / seconds"""
    )
}

class "PhysxSchemaPhysxArticulationAPI" (
    doc = "PhysX articulation extended parameters."
)
{
    bool physxArticulation:articulationEnabled = 1 (
        doc = "Boolean defining whether articulation is enabled or disabled."
    )
    bool physxArticulation:enabledSelfCollisions = 1 (
        doc = "Boolean defining whether self collisions should be enabled or disabled."
    )
    float physxArticulation:sleepThreshold = 0.00005 (
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf) Default: 0.00005 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
    int physxArticulation:solverPositionIterationCount = 32 (
        doc = """Solver position iteration counts for the body.
            Allowed range [1, 255]."""
    )
    int physxArticulation:solverVelocityIterationCount = 1 (
        doc = """Solver velocity iteration counts for the body.
            Allowed range [0, 255]."""
    )
    float physxArticulation:stabilizationThreshold = 0.00001 (
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf) Default: 0.00001 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxSchemaPhysxCameraAPI" (
    doc = "PhysX camera."
)
{
    bool alwaysUpdateEnabled = 1 (
        doc = """When enabled, always update this camera whether it is the active camera or not.
            This prevents cameras from slewing into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
}

class "PhysxSchemaPhysxCameraDroneAPI" (
    doc = "PhysX drone camera that follows its subject from the air as it drives."
)
{
    float physxDroneCamera:feedForwardVelocityGain (
        doc = "The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"
    )
    float physxDroneCamera:followDistance (
        doc = "The distance from the subject that the drone attempts to maintain. e.g. 30 meters"
    )
    float physxDroneCamera:followHeight (
        doc = "The height above the subject that the drone attmepts to maintain. e.g. 15 meters"
    )
    float physxDroneCamera:horizontalVelocityGain (
        doc = "The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"
    )
    float physxDroneCamera:maxDistance (
        doc = "The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"
    )
    float physxDroneCamera:maxSpeed (
        doc = "The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"
    )
    float3 physxDroneCamera:positionOffset (
        doc = "An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"
    )
    float physxDroneCamera:rotationFilterTimeConstant (
        doc = "The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"
    )
    float physxDroneCamera:velocityFilterTimeConstant (
        doc = "The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"
    )
    float physxDroneCamera:verticalVelocityGain (
        doc = "The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"
    )
}

class "PhysxSchemaPhysxCameraFollowAPI" (
    doc = "PhysX camera that follows behind the subject as it moves."
)
{
    float3 physxFollowCamera:cameraPositionTimeConstant (
        doc = "Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"
    )
    float physxFollowCamera:followMaxDistance (
        doc = "The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"
    )
    float physxFollowCamera:followMaxSpeed (
        doc = "The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"
    )
    float physxFollowCamera:followMinDistance (
        doc = "The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"
    )
    float physxFollowCamera:followMinSpeed (
        doc = "The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"
    )
    float physxFollowCamera:followTurnRateGain (
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject.
            Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowCamera:lookAheadMaxSpeed (
        doc = "The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"
    )
    float physxFollowCamera:lookAheadMinDistance (
        doc = "The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"
    )
    float physxFollowCamera:lookAheadMinSpeed (
        doc = "The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"
    )
    float physxFollowCamera:lookAheadTurnRateGain (
        doc = "A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"
    )
    float physxFollowCamera:lookPositionHeight (
        doc = "Distance to elevate the camera look point. e.g. 50.0 cm"
    )
    float3 physxFollowCamera:lookPositionTimeConstant (
        doc = "Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"
    )
    float physxFollowCamera:pitchAngle (
        doc = "The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"
    )
    float physxFollowCamera:pitchAngleTimeConstant (
        doc = "Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"
    )
    float3 physxFollowCamera:positionOffset (
        doc = "Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"
    )
    float physxFollowCamera:slowPitchAngleSpeed (
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"
    )
    float physxFollowCamera:slowSpeedPitchAngleScale (
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"
    )
    float physxFollowCamera:velocityNormalMinSpeed (
        doc = "The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"
    )
    float physxFollowCamera:yawAngle (
        doc = "The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"
    )
    float physxFollowCamera:yawRateTimeConstant (
        doc = "Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"
    )
    float physxFollowFollowCamera:lookAheadMaxDistance (
        doc = "The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 500.0 cm"
    )
}

class "PhysxSchemaPhysxCameraFollowLookAPI" (
    doc = """PhysX camera that follows behind the subject's forward vector as it moves.
        Assumes the subject is always upright and does not roll."""
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        doc = "The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"
    )
    float physxFollowLookCamera:downHillGroundPitch (
        doc = "The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:followReverseDistance (
        doc = "The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"
    )
    float physxFollowLookCamera:followReverseSpeed (
        doc = "The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"
    )
    float physxFollowLookCamera:upHillGroundAngle (
        doc = "The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"
    )
    float physxFollowLookCamera:upHillGroundPitch (
        doc = "The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:velocityBlendTimeConstant (
        doc = "Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"
    )
}

class "PhysxSchemaPhysxCameraFollowVelocityAPI" (
    doc = "PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."
)
{
}

class "PhysxSchemaPhysxCharacterControllerAPI" (
    doc = '''PhysxCharacterControllerAPI can be applied to a capsuleGeom.
        It will turn the capsule into a character controller.
        For any described attribute Fallback Value or Allowed Values below that are text/tokens, 
        the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.'''
)
{
    uniform token physxCharacterController:climbingMode = "easy" (
        allowedTokens = ["easy", "constrained"]
        doc = "The climbing mode."
    )
    float physxCharacterController:contactOffset = 0.1 (
        doc = "The contact offset used by the controller. Range: [0, inf) Units: distance"
    )
    float physxCharacterController:invisibleWallHeight = 0 (
        doc = "Height of invisible walls created around non-walkable triangles. Range: [0, inf) Units: distance"
    )
    float physxCharacterController:maxJumpHeight = 0 (
        doc = "Maximum height a jumping character can reach. Range: [0, inf) Units: distance"
    )
    vector3f physxCharacterController:moveTarget = (0, 0, 0) (
        doc = "Desired target position that CCT should try to reach."
    )
    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        doc = "The non-walkable mode controls if a character controller slides or not on a non-walkable part."
    )
    float physxCharacterController:scaleCoeff = 0.8 (
        doc = "Scale coefficient for underlying kinematic actor. Range: [0, inf) Units: dimensionless"
    )
    float physxCharacterController:slopeLimit = 0.3 (
        doc = "Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. A value of 0 disables this feature."
    )
    float physxCharacterController:stepOffset = 0.5 (
        doc = "Defines the maximum height of an obstacle which the character can climb. Range: [0, inf) Units: distance"
    )
    uniform token physxCharacterController:upAxis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = "Up axis for stepping functionality."
    )
    float physxCharacterController:volumeGrowth = 1.5 (
        doc = "Cached volume growth. Range: [0, inf) Units: dimensionless"
    )
}

class "PhysxSchemaPhysxCollisionAPI" (
    doc = "PhysX collision extended parameters."
)
{
    float physxCollision:contactOffset = -inf (
        doc = "Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent. Range: [maximum(0, restOffset), inf) Units: distance"
    )
    float physxCollision:minTorsionalPatchRadius = 0 (
        doc = "Defines the minimum radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"
    )
    float physxCollision:restOffset = -inf (
        doc = "Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value. For rigid bodies, this value is zero. Range: [0, contactOffset] Units: distance"
    )
    float physxCollision:torsionalPatchRadius = 0 (
        doc = "Defines the radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"
    )
}

class "PhysxSchemaPhysxContactReportAPI" (
    doc = "Enables contact reporting for a rigid body or articulation."
)
{
    float physxContactReport:threshold = 1 (
        doc = "Sets the force threshold for contact reports. Range: [0, inf] Units: force = mass * distance / seconds^2"
    )
}

class "PhysxSchemaPhysxConvexDecompositionCollisionAPI" (
    doc = "PhysX convex decomposition(VHACD) extended parameters."
)
{
    float physxConvexDecompositionCollision:errorPercentage = 10 (
        doc = "Convex decomposition errorPercentage parameter."
    )
    int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        doc = "Maximum of convex hulls created during convex decomposition."
    )
    float physxConvexDecompositionCollision:minThickness = 0.001 (
        doc = "Convex hull min thickness. Range: [0, inf) Units: distance"
    )
    bool physxConvexDecompositionCollision:shrinkWrap = 0 (
        doc = "Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."
    )
    int physxConvexDecompositionCollision:voxelResolution = 500000 (
        doc = "Voxel resolution used for convex decomposition."
    )
}

class "PhysxSchemaPhysxConvexHullCollisionAPI" (
    doc = "PhysX convex hull collision extended parameters."
)
{
    int physxConvexHullCollision:hullVertexLimit = 64 (
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    float physxConvexHullCollision:minThickness = 0.001 (
        doc = "Convex hull minimum thickness. Range: [0, inf) Units: distance"
    )
}

class "PhysxSchemaPhysxCookedDataAPI" (
    doc = "PhysX cooked data storage."
)
{
    uchar[] physxCookedData:__INSTANCE_NAME__:buffer (
        doc = "CookedData"
    )
}

class "PhysxSchemaPhysxForceAPI" (
    doc = """
        PhysX schema API that applies a force and torque to a rigid body (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI).

        The API can be applied to either:

        The rigid-body Xformable, in which case the force is applied at the body's center of mass.
        To an UsdGeom.Xformable that is a child of the rigid-body Xformable, in which case the force is applied at the location defined by the Xformable.
        The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. Note that any scale transform operations will only affect the force and torque values if on \"acceleration\" mode.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value \"rightHanded\", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    vector3f physxForce:force = (0, 0, 0) (
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled.

        The force is applied at the position defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied directly to a rigid-body Xformable. For units see mode attribute. Range: (-inf, inf)
    """
    )
    bool physxForce:forceEnabled = 1 (
        doc = "Boolean defining whether the force and torque are enabled or disabled."
    )
    uniform token physxForce:mode = "acceleration" (
        allowedTokens = ["acceleration", "force"]
        doc = """
        Force mode, can be either a force or an acceleration.

        force - units: (linear) mass * distance / seconds^2, i.e. a force (angular) mass * distance * distance / time^2, 
        i.e. a torque acceleration - units: (linear) distance / seconds^2, i.e. a linear acceleration. (angular) degrees / seconds^2, i.e. an angular acceleration.
        """
    )
    vector3f physxForce:torque = (0, 0, 0) (
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled.
            For units see mode attribute. Range: (-inf, inf)"""
    )
    bool physxForce:worldFrameEnabled = 0 (
        doc = "Boolean defining whether the force and torque are in world frame or in local frame."
    )
}

class "PhysxSchemaPhysxIsosurfaceAPI" (
    doc = """Applied to a PhysxParticleSystem.
        Defines settings to extract an isosurface from the particles in the particle system."""
)
{
    float physxIsosurface:anisotropyMax = 2 (
        doc = """The maximal scale anisotropy can apply to a particle radius.
            Range: [anisotropyMin, inf) Units: dimensionless"""
    )
    float physxIsosurface:anisotropyMin = 0.1 (
        doc = """The minimal scale anisotropy can apply to a particle radius.
            Range: [0, anisotropyMax] Units: dimensionless"""
    )
    float physxIsosurface:anisotropyRadius = 0.5 (
        doc = """Radius that defines the size of the neighborhood used to determine the anisotropy information.
            Range: [0, inf) Units: distance"""
    )
    bool physxIsosurface:enableAnisotropy = 0 (
        doc = "Enables usage of anisotropy information during isosurface extraction process."
    )
    string physxIsosurface:gridFilteringPasses = "GSRS" (
        doc = '''Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. 
        Up to 8 passes, every pass can consist of up to 4 repetitions.'''
    )
    float physxIsosurface:gridSmoothingRadiusRelativeToCellSize = 0.5 (
        doc = """The radius used during the smoothing process on the grid.
        It is measured relative to the grid's cell size. Range: [0, inf) Units: dimensionless"""
    )
    float physxIsosurface:gridSpacing = 0.25 (
        doc = """Cell Size of the grid used for isosurface extraction.
        Range: (0, inf) Units: distance"""
    )
    bool physxIsosurface:isoSurfaceEnabled = 1 (
        doc = "Enable or disable the creation of an isosurface."
    )
    float physxIsosurface:isosurfaceLevel = -0.3 (
        doc = """The level at which the isosurface is located.
        Allows to control the droplet size. The signed distance field is more negative towards the center of the fluid and positive outside. Range: (-inf, inf) Units: distance"""
    )
    float physxIsosurface:kernelRadius = 0.5 (
        doc = """Radius of the kernel used to transfer the density to the isosurface grid.
        Range: (0, inf) Units: distance"""
    )
    int physxIsosurface:maxSubgrids = 1024 (
        doc = """Maximum number of blocks the sparse grid structure can contain.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxTriangles = 2097152 (
        doc = """Maximum number of triangles the extracted isosurface can have.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxVertices = 1048576 (
        doc = """Maximum number of vertices the extracted isosurface can have.
        Range: [3, inf)"""
    )
    int physxIsosurface:numMeshSmoothingPasses = 2 (
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
        Using an even number of passes leads to less shrinking. Range: [0, inf)"""
    )
}

class "PhysxSchemaPhysxJointAPI" (
    doc = "PhysX joint extended parameters."
)
{
    float physxJoint:armature = 0 (
        doc = """Armature can help stabilize an articulation by adding to the inertial response of a joint.
        Conceptually, armature represents the inertia of an actuator driving the joint. Note that this parameter is used only when the joint belongs to an articulation. 
        Range: [0, inf) Units: Linear joint - mass Angular joint - mass * (distance)^2
        """
    )
    bool physxJoint:enableProjection = 0 (
        doc = "Whether the actors should get projected for this constraint (the direction will be chosen by PhysX)."
    )
    float physxJoint:jointFriction = 0 (
        doc = """Joint friction.
        Only applies for joints that are parts of an articulation. Range: [0, inf) Units: dimensionless"""
    )
    float physxJoint:maxJointVelocity = 1000000 (
        doc = """Maximum joint velocity.
        Range: [0, inf) Units: Linear joint - distance / time Angular joint - degrees / time"""
    )
}

class "PhysxSchemaPhysxMaterialAPI" (
    doc = '''PhysX material extended parameters.
    For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. 
    So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    '''
)
{
    bool physxMaterial:compliantContactAccelerationSpring = 0 (
        doc = """If enabled, switches from force-based to acceleration-based compliant spring-damper contact effects.
        An acceleration-based spring-damper directly influences the acceleration of (rather than the force on) the contacting bodies, 
        which makes the sink-in depth independent of the mass. The setting has no effect if compliant contacts are disabled, i.e., if the compliant contact stiffness is zero.
        """
    )
    float physxMaterial:compliantContactDamping = 0 (
        doc = """Damping coefficient for a compliant contact model using implicit springs.

        Ignored if compliant contacts are disabled (compliantContactStiffness is set to zero), in which case rigid contacts are active. 
        Depending on the compliantContactAccelerationSpring setting, the damping is interpreted as a force or acceleration, respectively, per unit velocity. 
        Range: [0, inf) Units (force spring): force / (distance / seconds) = mass / seconds Units (acceleration spring): acceleration / (distance / seconds) = 1 / seconds
        """
    )
    float physxMaterial:compliantContactStiffness = 0 (
        doc = """Spring stiffness for a compliant contact model using implicit springs.

        A higher stiffness results in behavior closer to a rigid contact. The compliant contact model is only enabled if the stiffness is larger than 0. 
        Depending on the compliantContactAccelerationSpring setting, the stiffness is interpreted as a force or acceleration, respectively, per unit distance. 
        Range: [0, inf) Units (force spring): force/distance = mass / seconds / seconds Units (acceleration spring): acceleration/distance = 1 / seconds / seconds
        """
    )
    uniform token physxMaterial:dampingCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a damping coefficient for a collision.

        This value is only relevant for compliant contact interactions.
        """
    )
    uniform token physxMaterial:frictionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a friction coefficient for a collision.
        """
    )
    uniform token physxMaterial:restitutionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a restitution coefficient for a collision.
        """
    )
}

