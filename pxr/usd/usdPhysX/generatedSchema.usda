#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "PhysxSchemaJointStateAPI" (
    doc = '''The PhysicsJointStateAPI is applied to a joint primitive (i.e. any PhysicsJoint-derived type)
    and provides read/write access to the joint position and velocity for a specific joint axis.
    The PhysicsJointStateAPI is a multipleApply schema, and its instance name TfToken defines the joint axis:
    The name can be "transX", "transY", "transZ", "rotX", "rotY", "rotZ"
    or its "linear" for prismatic joint or "angular" for revolute joints, respectively.
'''
)
{
    float jointState:__INSTANCE_NAME__:physics:position (
        doc = """Joint state position defines the relative difference between joint body0 frame and joint body1 frame in world frame.
               Range: (-inf, inf) Units: linear - distance angular - degrees"""
    )
    float jointState:__INSTANCE_NAME__:physics:velocity (
        doc = """Joint state velocity defines the relative velocity between joint body0 and joint body1.
               Range: (-inf, inf) Units: linear - distance / seconds angular - degrees / seconds"""
    )
}

class "PhysxSchemaPhysxArticulationAPI" (
    doc = "PhysX articulation extended parameters."
)
{
    bool physxArticulation:articulationEnabled = 1 (
        doc = "Boolean defining whether articulation is enabled or disabled."
    )
    bool physxArticulation:enabledSelfCollisions = 1 (
        doc = "Boolean defining whether self collisions should be enabled or disabled."
    )
    float physxArticulation:sleepThreshold = 0.00005 (
        doc = """Mass-normalized kinetic energy threshold below which the articulation may go to sleep.
            Range: [0, inf) Default: 0.00005 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
    int physxArticulation:solverPositionIterationCount = 32 (
        doc = """Solver position iteration counts for the body.
            Allowed range [1, 255]."""
    )
    int physxArticulation:solverVelocityIterationCount = 1 (
        doc = """Solver velocity iteration counts for the body.
            Allowed range [0, 255]."""
    )
    float physxArticulation:stabilizationThreshold = 0.00001 (
        doc = """The mass-normalized kinetic energy threshold below which the articulation may participate in stabilization.
            Range: [0, inf) Default: 0.00001 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds"""
    )
}

class "PhysxSchemaPhysxCameraAPI" (
    doc = "PhysX camera."
)
{
    bool alwaysUpdateEnabled = 1 (
        doc = """When enabled, always update this camera whether it is the active camera or not.
            This prevents cameras from slewing into position when switching to a new active camera. When disabled, only the active camera is updated, saving time."""
    )
}

class "PhysxSchemaPhysxCameraDroneAPI" (
    doc = "PhysX drone camera that follows its subject from the air as it drives."
)
{
    float physxDroneCamera:feedForwardVelocityGain (
        doc = "The higher the gain, the more closely the drone will match the velocity of the subject and the more connected it will appear. e.g. 0.1"
    )
    float physxDroneCamera:followDistance (
        doc = "The distance from the subject that the drone attempts to maintain. e.g. 30 meters"
    )
    float physxDroneCamera:followHeight (
        doc = "The height above the subject that the drone attmepts to maintain. e.g. 15 meters"
    )
    float physxDroneCamera:horizontalVelocityGain (
        doc = "The higher the gain, the faster the drone will accelerate towards the target position. e.g. 1.0"
    )
    float physxDroneCamera:maxDistance (
        doc = "The maximum distance allowed from the subject before the drone resets to the target position. e.g. 100 meters"
    )
    float physxDroneCamera:maxSpeed (
        doc = "The maximum speed the drone is allowed to move. e.g. 20.0 meters/second"
    )
    float3 physxDroneCamera:positionOffset (
        doc = "An offset vector from the subject origin at which the drone looks. e.g. (0.0 m, 0.0 m, 0.0 m)"
    )
    float physxDroneCamera:rotationFilterTimeConstant (
        doc = "The angular velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 0.2 seconds"
    )
    float physxDroneCamera:velocityFilterTimeConstant (
        doc = "The velocity of the drone is filtered to make it appear as if it is accelerating. e.g. 1.0 seconds"
    )
    float physxDroneCamera:verticalVelocityGain (
        doc = "The higher the gain, the higher the climb or descent rate of the drone to get to the target altitude. e.g. 1.0"
    )
}

class "PhysxSchemaPhysxCameraFollowAPI" (
    doc = "PhysX camera that follows behind the subject as it moves."
)
{
    float3 physxFollowCamera:cameraPositionTimeConstant (
        doc = "Filter time constant for the position of the camera for each axis, in seconds. e.g. (0.5 sec, 0.1 sec, 0.5 sec)"
    )
    float physxFollowCamera:followMaxDistance (
        doc = "The maximum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1000.0 cm"
    )
    float physxFollowCamera:followMaxSpeed (
        doc = "The maximum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm/sec"
    )
    float physxFollowCamera:followMinDistance (
        doc = "The minimum distance used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm"
    )
    float physxFollowCamera:followMinSpeed (
        doc = "The minimum speed used for a linear interpolation to compute the follow distance of the camera. e.g. 300.0 cm/sec"
    )
    float physxFollowCamera:followTurnRateGain (
        doc = """A scale factor that multiplies the filtered yaw rate to yaw the camera position behind the subject.
            Can be any positive or negative number. e.g. 0.2"""
    )
    float physxFollowCamera:lookAheadMaxSpeed (
        doc = "The maximum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 2000.0 cm"
    )
    float physxFollowCamera:lookAheadMinDistance (
        doc = "The minimum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm"
    )
    float physxFollowCamera:lookAheadMinSpeed (
        doc = "The minimum speed used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 0.0 cm/sec"
    )
    float physxFollowCamera:lookAheadTurnRateGain (
        doc = "A scale factor that multiplies the filtered yaw rate to yaw the camera look point left or right. Can be any positive or negative number. e.g. 0.2"
    )
    float physxFollowCamera:lookPositionHeight (
        doc = "Distance to elevate the camera look point. e.g. 50.0 cm"
    )
    float3 physxFollowCamera:lookPositionTimeConstant (
        doc = "Filter time constant for the camera look point, in seconds. e.g. (0.2 sec, 0.5 sec, 0.2 sec)"
    )
    float physxFollowCamera:pitchAngle (
        doc = "The pitch angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 15 degrees"
    )
    float physxFollowCamera:pitchAngleTimeConstant (
        doc = "Time constant to filter the pitch angle, in seconds. Used to pitch the camera up and down when driving up or down hills. e.g. 0.2 seconds"
    )
    float3 physxFollowCamera:positionOffset (
        doc = "Position offset from the subject center of mass from which the camera follow vector and look vector are computed. e.g. (0.0 cm, 10.0 cm, 0.0 cm)"
    )
    float physxFollowCamera:slowPitchAngleSpeed (
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 1000 cm/sec"
    )
    float physxFollowCamera:slowSpeedPitchAngleScale (
        doc = "Scale of the camera pitch angle at slow speed. This lowers the camera behind the subject at slow speeds. e.g. 0.5"
    )
    float physxFollowCamera:velocityNormalMinSpeed (
        doc = "The minimum speed, below which, the subject look vector must be used because the normalized velocity vector is too erratic. e.g. 600.0 cm/sec"
    )
    float physxFollowCamera:yawAngle (
        doc = "The yaw angle of the follow vector around the subject. Zero is directly behind the subject. e.g. 0 degrees"
    )
    float physxFollowCamera:yawRateTimeConstant (
        doc = "Time constant to filter the subject yaw rate, in seconds. Use to look into turns. e.g. 0.2 sec"
    )
    float physxFollowFollowCamera:lookAheadMaxDistance (
        doc = "The maximum distance used for a linear interpolation to compute the look ahead distance of the camera look point. e.g. 500.0 cm"
    )
}

class "PhysxSchemaPhysxCameraFollowLookAPI" (
    doc = """PhysX camera that follows behind the subject's forward vector as it moves.
        Assumes the subject is always upright and does not roll."""
)
{
    float physxFollowLookCamera:downHillGroundAngle (
        doc = "The minimum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. -45.0 degrees"
    )
    float physxFollowLookCamera:downHillGroundPitch (
        doc = "The minimum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:followReverseDistance (
        doc = "The maximum distance, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 3000.0 cm"
    )
    float physxFollowLookCamera:followReverseSpeed (
        doc = "The positive, maximum speed, when driving in reverse, used for a linear interpolation to compute the follow distance of the camera. e.g. 1500.0 cm/sec"
    )
    float physxFollowLookCamera:upHillGroundAngle (
        doc = "The maximum pitch angle of the terrain used for a linear interpolation to adjust the pitch of the camera. e.g. 45.0 degrees"
    )
    float physxFollowLookCamera:upHillGroundPitch (
        doc = "The maximum pitch angle of the camera used for a linear interpolation to adjust the pitch of the camera. e.g. 10.0 degrees"
    )
    float physxFollowLookCamera:velocityBlendTimeConstant (
        doc = "Filter time constant to blend between the look and velocity vectors, in seconds. e.g. 0.1 seconds"
    )
}

class "PhysxSchemaPhysxCameraFollowVelocityAPI" (
    doc = "PhysX camera that follows behind the subject's velocity vector as it moves, which allows the subject to roll and tumble."
)
{
}

class "PhysxSchemaPhysxCharacterControllerAPI" (
    doc = '''PhysxCharacterControllerAPI can be applied to a capsuleGeom.
        It will turn the capsule into a character controller.
        For any described attribute Fallback Value or Allowed Values below that are text/tokens, 
        the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.'''
)
{
    uniform token physxCharacterController:climbingMode = "easy" (
        allowedTokens = ["easy", "constrained"]
        doc = "The climbing mode."
    )
    float physxCharacterController:contactOffset = 0.1 (
        doc = "The contact offset used by the controller. Range: [0, inf) Units: distance"
    )
    float physxCharacterController:invisibleWallHeight = 0 (
        doc = "Height of invisible walls created around non-walkable triangles. Range: [0, inf) Units: distance"
    )
    float physxCharacterController:maxJumpHeight = 0 (
        doc = "Maximum height a jumping character can reach. Range: [0, inf) Units: distance"
    )
    vector3f physxCharacterController:moveTarget = (0, 0, 0) (
        doc = "Desired target position that CCT should try to reach."
    )
    uniform token physxCharacterController:nonWalkableMode = "preventClimbing" (
        allowedTokens = ["preventClimbing", "preventClimbingForceSliding"]
        doc = "The non-walkable mode controls if a character controller slides or not on a non-walkable part."
    )
    float physxCharacterController:scaleCoeff = 0.8 (
        doc = "Scale coefficient for underlying kinematic actor. Range: [0, inf) Units: dimensionless"
    )
    float physxCharacterController:slopeLimit = 0.3 (
        doc = "Slope limit which the CCT can climb. The limit is expressed as the cosine of the desired limit angle. A value of 0 disables this feature."
    )
    float physxCharacterController:stepOffset = 0.5 (
        doc = "Defines the maximum height of an obstacle which the character can climb. Range: [0, inf) Units: distance"
    )
    uniform token physxCharacterController:upAxis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = "Up axis for stepping functionality."
    )
    float physxCharacterController:volumeGrowth = 1.5 (
        doc = "Cached volume growth. Range: [0, inf) Units: dimensionless"
    )
}

class "PhysxSchemaPhysxCollisionAPI" (
    doc = "PhysX collision extended parameters."
)
{
    float physxCollision:contactOffset = -inf (
        doc = "Contact offset of a collision shape. Default value -inf means default is picked by the simulation based on the shape extent. Range: [maximum(0, restOffset), inf) Units: distance"
    )
    float physxCollision:minTorsionalPatchRadius = 0 (
        doc = "Defines the minimum radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"
    )
    float physxCollision:restOffset = -inf (
        doc = "Rest offset of a collision shape. Default value -inf means that the simulation sets a suitable value. For rigid bodies, this value is zero. Range: [0, contactOffset] Units: distance"
    )
    float physxCollision:torsionalPatchRadius = 0 (
        doc = "Defines the radius of the contact patch used to apply torsional friction. Range: [0, inf) Units: distance"
    )
}

class "PhysxSchemaPhysxContactReportAPI" (
    doc = "Enables contact reporting for a rigid body or articulation."
)
{
    float physxContactReport:threshold = 1 (
        doc = "Sets the force threshold for contact reports. Range: [0, inf] Units: force = mass * distance / seconds^2"
    )
}

class "PhysxSchemaPhysxConvexDecompositionCollisionAPI" (
    doc = "PhysX convex decomposition(VHACD) extended parameters."
)
{
    float physxConvexDecompositionCollision:errorPercentage = 10 (
        doc = "Convex decomposition errorPercentage parameter."
    )
    int physxConvexDecompositionCollision:hullVertexLimit = 64 (
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    int physxConvexDecompositionCollision:maxConvexHulls = 32 (
        doc = "Maximum of convex hulls created during convex decomposition."
    )
    float physxConvexDecompositionCollision:minThickness = 0.001 (
        doc = "Convex hull min thickness. Range: [0, inf) Units: distance"
    )
    bool physxConvexDecompositionCollision:shrinkWrap = 0 (
        doc = "Attempts to adjust the convex hull points so that they are projected onto the surface of the original graphics mesh."
    )
    int physxConvexDecompositionCollision:voxelResolution = 500000 (
        doc = "Voxel resolution used for convex decomposition."
    )
}

class "PhysxSchemaPhysxConvexHullCollisionAPI" (
    doc = "PhysX convex hull collision extended parameters."
)
{
    int physxConvexHullCollision:hullVertexLimit = 64 (
        doc = "Convex hull vertex limit used for convex hull cooking."
    )
    float physxConvexHullCollision:minThickness = 0.001 (
        doc = "Convex hull minimum thickness. Range: [0, inf) Units: distance"
    )
}

class "PhysxSchemaPhysxCookedDataAPI" (
    doc = "PhysX cooked data storage."
)
{
    uchar[] physxCookedData:__INSTANCE_NAME__:buffer (
        doc = "CookedData"
    )
}

class "PhysxSchemaPhysxForceAPI" (
    doc = """
        PhysX schema API that applies a force and torque to a rigid body (UsdGeom.Xformable with UsdPhysicsRigidBodyAPI).

        The API can be applied to either:

        The rigid-body Xformable, in which case the force is applied at the body's center of mass.
        To an UsdGeom.Xformable that is a child of the rigid-body Xformable, in which case the force is applied at the location defined by the Xformable.
        The worldFrameEnabled flag defines what coordinate frame the force and torque are expressed in. Note that any scale transform operations will only affect the force and torque values if on \"acceleration\" mode.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value \"rightHanded\", use PhysxSchemaTokens->rightHanded as the value.
    """
)
{
    vector3f physxForce:force = (0, 0, 0) (
        doc = """Force to apply defined in global or local frame depending on worldFrameEnabled.

        The force is applied at the position defined by the relative transform to the parent rigid-body Xformable, or at the body's center of mass if the API is applied directly to a rigid-body Xformable. For units see mode attribute. Range: (-inf, inf)
    """
    )
    bool physxForce:forceEnabled = 1 (
        doc = "Boolean defining whether the force and torque are enabled or disabled."
    )
    uniform token physxForce:mode = "acceleration" (
        allowedTokens = ["acceleration", "force"]
        doc = """
        Force mode, can be either a force or an acceleration.

        force - units: (linear) mass * distance / seconds^2, i.e. a force (angular) mass * distance * distance / time^2, 
        i.e. a torque acceleration - units: (linear) distance / seconds^2, i.e. a linear acceleration. (angular) degrees / seconds^2, i.e. an angular acceleration.
        """
    )
    vector3f physxForce:torque = (0, 0, 0) (
        doc = """Torque to apply defined in the global or local frame depending on worldFrameEnabled.
            For units see mode attribute. Range: (-inf, inf)"""
    )
    bool physxForce:worldFrameEnabled = 0 (
        doc = "Boolean defining whether the force and torque are in world frame or in local frame."
    )
}

class "PhysxSchemaPhysxIsosurfaceAPI" (
    doc = """Applied to a PhysxParticleSystem.
        Defines settings to extract an isosurface from the particles in the particle system."""
)
{
    float physxIsosurface:anisotropyMax = 2 (
        doc = """The maximal scale anisotropy can apply to a particle radius.
            Range: [anisotropyMin, inf) Units: dimensionless"""
    )
    float physxIsosurface:anisotropyMin = 0.1 (
        doc = """The minimal scale anisotropy can apply to a particle radius.
            Range: [0, anisotropyMax] Units: dimensionless"""
    )
    float physxIsosurface:anisotropyRadius = 0.5 (
        doc = """Radius that defines the size of the neighborhood used to determine the anisotropy information.
            Range: [0, inf) Units: distance"""
    )
    bool physxIsosurface:enableAnisotropy = 0 (
        doc = "Enables usage of anisotropy information during isosurface extraction process."
    )
    string physxIsosurface:gridFilteringPasses = "GSRS" (
        doc = '''Grid filtering sequence, defined as capital letters "S":Smooth, "G":Grow, "R":Reduce. 
        Up to 8 passes, every pass can consist of up to 4 repetitions.'''
    )
    float physxIsosurface:gridSmoothingRadiusRelativeToCellSize = 0.5 (
        doc = """The radius used during the smoothing process on the grid.
        It is measured relative to the grid's cell size. Range: [0, inf) Units: dimensionless"""
    )
    float physxIsosurface:gridSpacing = 0.25 (
        doc = """Cell Size of the grid used for isosurface extraction.
        Range: (0, inf) Units: distance"""
    )
    bool physxIsosurface:isoSurfaceEnabled = 1 (
        doc = "Enable or disable the creation of an isosurface."
    )
    float physxIsosurface:isosurfaceLevel = -0.3 (
        doc = """The level at which the isosurface is located.
        Allows to control the droplet size. The signed distance field is more negative towards the center of the fluid and positive outside. Range: (-inf, inf) Units: distance"""
    )
    float physxIsosurface:kernelRadius = 0.5 (
        doc = """Radius of the kernel used to transfer the density to the isosurface grid.
        Range: (0, inf) Units: distance"""
    )
    int physxIsosurface:maxSubgrids = 1024 (
        doc = """Maximum number of blocks the sparse grid structure can contain.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxTriangles = 2097152 (
        doc = """Maximum number of triangles the extracted isosurface can have.
        Range: [1, inf)"""
    )
    int physxIsosurface:maxVertices = 1048576 (
        doc = """Maximum number of vertices the extracted isosurface can have.
        Range: [3, inf)"""
    )
    int physxIsosurface:numMeshSmoothingPasses = 2 (
        doc = """Number of smoothing passes applied to the generated isosurface triangle mesh.
        Using an even number of passes leads to less shrinking. Range: [0, inf)"""
    )
}

class "PhysxSchemaPhysxJointAPI" (
    doc = "PhysX joint extended parameters."
)
{
    float physxJoint:armature = 0 (
        doc = """Armature can help stabilize an articulation by adding to the inertial response of a joint.
        Conceptually, armature represents the inertia of an actuator driving the joint. Note that this parameter is used only when the joint belongs to an articulation. 
        Range: [0, inf) Units: Linear joint - mass Angular joint - mass * (distance)^2
        """
    )
    bool physxJoint:enableProjection = 0 (
        doc = "Whether the actors should get projected for this constraint (the direction will be chosen by PhysX)."
    )
    float physxJoint:jointFriction = 0 (
        doc = """Joint friction.
        Only applies for joints that are parts of an articulation. Range: [0, inf) Units: dimensionless"""
    )
    float physxJoint:maxJointVelocity = 1000000 (
        doc = """Maximum joint velocity.
        Range: [0, inf) Units: Linear joint - distance / time Angular joint - degrees / time"""
    )
}

class "PhysxSchemaPhysxMaterialAPI" (
    doc = '''PhysX material extended parameters.
    For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. 
    So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    '''
)
{
    bool physxMaterial:compliantContactAccelerationSpring = 0 (
        doc = """If enabled, switches from force-based to acceleration-based compliant spring-damper contact effects.
        An acceleration-based spring-damper directly influences the acceleration of (rather than the force on) the contacting bodies, 
        which makes the sink-in depth independent of the mass. The setting has no effect if compliant contacts are disabled, i.e., if the compliant contact stiffness is zero.
        """
    )
    float physxMaterial:compliantContactDamping = 0 (
        doc = """Damping coefficient for a compliant contact model using implicit springs.

        Ignored if compliant contacts are disabled (compliantContactStiffness is set to zero), in which case rigid contacts are active. 
        Depending on the compliantContactAccelerationSpring setting, the damping is interpreted as a force or acceleration, respectively, per unit velocity. 
        Range: [0, inf) Units (force spring): force / (distance / seconds) = mass / seconds Units (acceleration spring): acceleration / (distance / seconds) = 1 / seconds
        """
    )
    float physxMaterial:compliantContactStiffness = 0 (
        doc = """Spring stiffness for a compliant contact model using implicit springs.

        A higher stiffness results in behavior closer to a rigid contact. The compliant contact model is only enabled if the stiffness is larger than 0. 
        Depending on the compliantContactAccelerationSpring setting, the stiffness is interpreted as a force or acceleration, respectively, per unit distance. 
        Range: [0, inf) Units (force spring): force/distance = mass / seconds / seconds Units (acceleration spring): acceleration/distance = 1 / seconds / seconds
        """
    )
    uniform token physxMaterial:dampingCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a damping coefficient for a collision.

        This value is only relevant for compliant contact interactions.
        """
    )
    uniform token physxMaterial:frictionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a friction coefficient for a collision.
        """
    )
    uniform token physxMaterial:restitutionCombineMode = "average" (
        allowedTokens = ["average", "min", "multiply", "max"]
        doc = """
        Determines the way in which two material properties will be combined to yield a restitution coefficient for a collision.
        """
    )
}

class "PhysxSchemaPhysxMeshMergeCollisionAPI" (
    doc = """PhysxMeshMergeCollisionAPI enables implicit mesh merging of given meshes with respect to physics collision geometry representation.

    It is expected that this API extends the UsdPhysics.CollisionAPI definition, the UsdPhysics.CollisionAPI is still required to be present together with this API to define the collision properties. All meshes that belong to the collisionmeshes collection will be merged into one mesh that will be used for collision representation. Note that the collection can also define what meshes should be excluded from the selection.

    This means that for example all meshes that belong to the collection will be represented as one convexHull rather than dozens of convexHulls per mesh.

    It is possible to collect meshes through the collection that do not belong to the same hierarchy. This is allowed, however if the collisions are part of a rigid body, the meshes that do not belong to the rigid body hierarchy wont move. As defined in the rigid body specification, only rigid body transformation is updated.

    Note that any changes to the meshes during runtime will get ignored.
    """
)
{
}

class "PhysxSchemaPhysxMimicJointAPI" (
    doc = '''Applied to a Physics Joint that must be part of an articulation.

    Supported joint types are: PhysicsRevoluteJoint (with a limit set), PhysicsPrismaticJoint as well as the more generic PhysicsJoint if all linear degrees of freedom are locked.

    This schema allows to interconnect the degrees of freedom of two joints according to the relationship: jointPosition + (gearing * referenceJointPosition) + offset = 0. This can be used to have, for example, one joint mimic the motion of another joint. The term "position" does not necessarily mean a translational unit, in the case of an angular degree of freedom it is an angle. The mimic joint operates on a single degree of freedom which is specified through the instance name of this multiple apply schema. The allowed instance name tokens are "rotX", "rotY" and "rotZ". See the documentation of the attribute referenceJointAxis for more info related to specifying the degree of freedom to operate on. Notes: 1) the two joints have to be part of the same articulation. 2) once the simulation has started, a significant performance penalty will be incurred if a mimic joint is added or removed, if the referenceJoint relationship is changed or if the referenceJointAxis attributes is modified. 3) the mimic joint relationship is interpreted as a two-way interaction and an impulse will get applied to the reference joint as well.

    For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    '''
)
{
    float physxMimicJoint:__INSTANCE_NAME__:gearing = 1 (
        doc = """The gearing coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
        Range: (-inf, inf) Units: unitless or degrees/distance or distance/degrees (the last two refer to scenarios where a linear degree of freedom is connected to an angular one or vice versa)
        """
    )
    float physxMimicJoint:__INSTANCE_NAME__:offset = 0 (
        doc = """The offset coefficient (see relationship formulation in the documentation part of PhysxMimicJointAPI).
        Range: (-inf, inf) Units: distance or degrees (depending on whether the mimic joint's degree of freedom is linear or angular)
        """
    )
    uniform token physxMimicJoint:__INSTANCE_NAME__:referenceJointAxis = "rotX" (
        allowedTokens = ["rotX", "rotY", "rotZ"]
        doc = """
        The axis that marks the degree of freedom of the reference joint to mimic.

        Has to be a valid degree of freedom on the reference joint. For joint types with a single degree of freedom (like PhysicsRevoluteJoint or PhysicsPrismaticJoint), 
        this attribute will be ignored since the axis is defined implicitly. 
        The mimic joint connects <targetJoint, targetJointAxis> to <referenceJoint, referenceJointAxis> with targetJoint being the prim that has PhysxMimicJointAPI applied 
        and targetJointAxis being defined through the instance name token of PhysxMimicJointAPI.
        """
    )
}

class "PhysxSchemaPhysxPhysicsDistanceJointAPI" (
    doc = "PhysX distance joint extended parameters."
)
{
    float physxPhysicsDistanceJoint:springDamping = 0 (
        doc = """Spring damping.
        Range: [0, inf) Units: force * seconds / distance = mass / seconds
        """
    )
    bool physxPhysicsDistanceJoint:springEnabled = 0 (
        doc = """Whether spring should be enabled.
        (default off)
        """
    )
    float physxPhysicsDistanceJoint:springStiffness = 0 (
        doc = """Spring stiffness.
        Range: [0, inf) Units: force / distance = mass / seconds^2
        """
    )
}

class PhysxSchemaPhysxPhysicsGearJoint "PhysxSchemaPhysxPhysicsGearJoint" (
    doc = "Predefined gear joint type."
)
{
    rel hinge0 (
        doc = "Relationship to first revolute joint."
    )
    rel hinge1 (
        doc = "Relationship to second revolute joint."
    )
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    float physics:gearRatio = 1 (
        doc = "Gear ratio Range: (-inf, inf) Units: dimensionless."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxSchemaPhysxPhysicsRackAndPinionJoint "PhysxSchemaPhysxPhysicsRackAndPinionJoint" (
    doc = "Predefined rack & pinion joint type."
)
{
    rel hinge (
        doc = "Relationship to revolute joint."
    )
    rel physics:body0 (
        displayName = "Body 0"
        doc = "Relationship to any UsdGeomXformable."
    )
    rel physics:body1 (
        displayName = "Body 1"
        doc = "Relationship to any UsdGeomXformable."
    )
    float physics:breakForce = inf (
        displayName = "Break Force"
        doc = """Joint break force. If set, joint is to break when this force
        limit is reached. (Used for linear DOFs.) 
        Units: mass * distance / second / second"""
    )
    float physics:breakTorque = inf (
        displayName = "Break Torque"
        doc = """Joint break torque. If set, joint is to break when this torque
        limit is reached. (Used for angular DOFs.) 
        Units: mass * distance * distance / second / second"""
    )
    bool physics:collisionEnabled = 0 (
        displayName = "Collision Enabled"
        doc = "Determines if the jointed subtrees should collide or not."
    )
    uniform bool physics:excludeFromArticulation = 0 (
        displayName = "Exclude From Articulation"
        doc = "Determines if the joint can be included in an Articulation."
    )
    bool physics:jointEnabled = 1 (
        displayName = "Joint Enabled"
        doc = "Determines if the joint is enabled."
    )
    point3f physics:localPos0 = (0, 0, 0) (
        displayName = "Local Position 0"
        doc = "Relative position of the joint frame to body0's frame."
    )
    point3f physics:localPos1 = (0, 0, 0) (
        displayName = "Local Position 1"
        doc = "Relative position of the joint frame to body1's frame."
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        displayName = "Local Rotation 0"
        doc = "Relative orientation of the joint frame to body0's frame."
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        displayName = "Local Rotation 1"
        doc = "Relative orientation of the joint frame to body1's frame."
    )
    float physics:ratio = 1 (
        doc = """Ratio between angular and linear motion. 
        Range: (-inf, inf) Units: degrees / distance"""
    )
    rel prismatic (
        doc = "Relationship to prismatic joint."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxSchemaPhysxPhysicsInstancer "PhysxSchemaPhysxPhysicsInstancer" (
    doc = "Core class for instancing physics prims."
)
{
    int[] physics:protoIndices (
        doc = "Per-instance index into prototypes relationship that identifies what physics prims are instanced. Topology attribute - can be animated, but at a potential performance impact for streaming."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class PhysxSchemaPhysxPhysicsJointInstancer "PhysxSchemaPhysxPhysicsJointInstancer" (
    doc = "Physics joint instancer, the prototypes are expected to be UsdPhysicsJoint prim types."
)
{
    int[] physics:body0Indices (
        doc = "**Optional property.** Only applicable if body0s is a point instancer. An index specifies the per-instance body0 rel as the rigid body at the body0s-instancer's protoIndices[index]."
    )
    int[] physics:body1Indices (
        doc = "**Optional property.** Only applicable if body1s is a point instancer. An index specifies the per-instance body1 rel as the rigid body at the body1s-instancer's protoIndices[index]."
    )
    point3f[] physics:localPos0s (
        doc = "**Required property.** Per-instance localPos0. This transformation is added on top of the joint localPos0."
    )
    point3f[] physics:localPos1s (
        doc = "**Required property.** Per-instance localPos1. This transformation is added on top of the joint localPos1."
    )
    quath[] physics:localRot0s (
        doc = "**Required property.** Per-instance localRot0. This transformation is added on top of the joint localPos0."
    )
    quath[] physics:localRot1s (
        doc = "**Required property.** Per-instance localRot1. This transformation is added on top of the joint localPos1."
    )
    int[] physics:protoIndices (
        doc = "Per-instance index into prototypes relationship that identifies what physics prims are instanced. Topology attribute - can be animated, but at a potential performance impact for streaming."
    )
    rel physicsBody0s (
        doc = "**Required property.** The rel must contain either exactly one UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage. If the rel is to a point instancer, the body0Indices must be specified."
    )
    rel physicsBody1s (
        doc = "**Required property.** The rel must contain either exactly one UsdGeomPointInstancer that instances rigid bodies; or one or more rigid-body prims in the stage. If the rel is to a point instancer, the body0Indices must be specified."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class "PhysxSchemaPhysxResidualReportingAPI" (
    doc = """
        Gives access to residual values that inform about the remaining physics solver error present during the last position and during the last velocity iteration.

        The residual reporting must be enabled on the Physics Scene, otherwise the reported values will be zero. The API can be applied to either:

        Joints. The joint residual will be reported.
        Articulation Roots. The RMS (root mean squared) and max value over all articulation joint residuals will be reported.
        Physics Scene. The RMS and max value over all error/residual sources (including contacts) will be reported.
    """
)
{
    float physxResidualReporting:maxResidualPositionIteration = 0 (
        doc = """The maximal magnitude of the physics solver error during the last position iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxResidualReporting:maxResidualVelocityIteration = 0 (
        doc = """The maximal magnitude of the physics solver error during the last velocity iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxResidualReporting:rmsResidualPositionIteration = 0 (
        doc = """The RMS (root mean squared) magnitude of the physics solver error during the last position iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxResidualReporting:rmsResidualVelocityIteration = 0 (
        doc = """The RMS (root mean squared) magnitude of the physics solver error during the last velocity iteration.
        Range: [0, inf) Units: dimensionless
        """
    )
}

class "PhysxSchemaPhysxRigidBodyAPI" (
    doc = """
        PhysX rigid body extended parameters.
    """
)
{
    float physxRigidBody:angularDamping = 0.05 (
        doc = """Angular damping coefficient.
        Range: [0, inf) Units: dimensionless
        """
    )
    float physxRigidBody:cfmScale = 0.025 (
        doc = """The cfm scale term can help stabilize an articulation by weakening the constraint's response.
        Use small values close to the default and typically in the range [0, 0.1] for best results. 
        Note that this parameter is currently used only if rigid body is part of an articulation. Range: [0, 1] Units: unitless
        """
    )
    float physxRigidBody:contactSlopCoefficient = 0 (
        doc = """Tolerance on the angular influence of a contact that can help improve the behavior of rolling approximate collision shapes.
        Specifically, the angular component of a normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. 
        The tolerance is scaled such that the behavior improvement persists through a range of angular velocities of a rolling shape. Range: [0, inf) Units: distance
        """
    )
    bool physxRigidBody:disableGravity = 0 (
        doc = """Disable gravity for the actor.
        """
    )
    bool physxRigidBody:enableCCD = 0 (
        doc = """Enables swept integration for the actor.
        """
    )
    bool physxRigidBody:enableGyroscopicForces = 1 (
        doc = """Enables computation of gyroscopic forces on the rigid body.
        """
    )
    bool physxRigidBody:enableSpeculativeCCD = 0 (
        doc = """Register a rigid body to dynamically adjust contact offset based on velocity.
        This can be used to achieve a CCD effect.
        """
    )
    float physxRigidBody:linearDamping = 0 (
        doc = """Linear damping coefficient.
        Range: [0, inf) Units: dimensionless
        """
    )
    int physxRigidBody:lockedPosAxis = 0 (
        doc = """Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2).
        """
    )
    int physxRigidBody:lockedRotAxis = 0 (
        doc = """Collection of flags providing a mechanism to lock motion along/around a specific axis (1 << 0, 1 << 1, 1 << 2).
        """
    )
    float physxRigidBody:maxAngularVelocity = 5729.58 (
        doc = """Maximum allowable angular velocity for rigid body.
        Range: [0, inf) Units: degrees / seconds
        """
    )
    float physxRigidBody:maxContactImpulse = inf (
        doc = """Sets a limit on the impulse that may be applied at a contact.
        The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. 
        For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body. Range: [0, inf) Units: force * seconds = mass * distance / seconds
        """
    )
    float physxRigidBody:maxDepenetrationVelocity = 3 (
        doc = """The maximum depenetration velocity permitted to be introduced by the solver.
        Range: [0, inf) Default: 5.0 * tolerancesLength Units: distance / seconds
        """
    )
    float physxRigidBody:maxLinearVelocity = inf (
        doc = """Maximum allowable linear velocity for the rigid body.
        Range: [0, inf) Units: distance / seconds
        """
    )
    bool physxRigidBody:retainAccelerations = 0 (
        doc = """Carries over forces/accelerations between frames, rather than clearing them.
        """
    )
    float physxRigidBody:sleepThreshold = 0.00005 (
        doc = """Mass-normalized kinetic energy threshold below which an actor may go to sleep.
        Range: [0, inf) Default: 0.00005 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds
        """
    )
    bool physxRigidBody:solveContact = 1 (
        doc = """Process the contacts of this rigid body in the dynamics solver.
        """
    )
    int physxRigidBody:solverPositionIterationCount = 16 (
        doc = """Solver position iteration counts for the body.
        Allowed range [1, 255].
        """
    )
    int physxRigidBody:solverVelocityIterationCount = 1 (
        doc = """Solver velocity iteration counts for the body.
        Allowed range [0, 255].
        """
    )
    float physxRigidBody:stabilizationThreshold = 0.00001 (
        doc = """Mass-normalized kinetic energy threshold below which an actor may participate in stabilization.
        Range: [0, inf) Default: 0.00001 * tolerancesSpeed * tolerancesSpeed Units: distance * distance / seconds / seconds
        """
    )
}

class "PhysxSchemaPhysxSceneAPI" (
    doc = '''
        PhysX scene extended parameters.

        Default PhysX material for the scene can be set by using material bind with purpose physics onto the PhysicsScene prim.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    '''
)
{
    float physxScene:bounceThreshold = 0 (
        doc = """A contact with a relative velocity below this will not bounce.
        Range: [0, inf) Default: 0 Units: distance / seconds
        """
    )
    uniform token physxScene:broadphaseType = "GPU" (
        allowedTokens = ["GPU", "MBP", "SAP"]
        doc = "Broad phase algorithm used in the simulation."
    )
    uniform token physxScene:collisionSystem = "PCM" (
        allowedTokens = ["PCM", "SAT"]
        doc = "Collision detection system."
    )
    bool physxScene:enableCCD = 0 (
        doc = """Enables a second broad phase check after integration that makes it possible to prevent objects from tunneling through each other.
        """
    )
    bool physxScene:enableEnhancedDeterminism = 0 (
        doc = """Provides improved determinism at the expense of performance.
        """
    )
    bool physxScene:enableExternalForcesEveryIteration = 0 (
        doc = """Enables greater TGS solver stability.
        """
    )
    bool physxScene:enableGPUDynamics = 1 (
        doc = """Enables the GPU dynamics pipeline.

        Required for GPU only features like deformables.
        """
    )
    bool physxScene:enableResidualReporting = 0 (
        doc = """Calculates solver residuals and reports them through optional Residual Report APIs at a slight expense of performance.
        """
    )
    bool physxScene:enableSceneQuerySupport = 1 (
        doc = """Enables scene query support for collision shapes.
        """
    )
    bool physxScene:enableStabilization = 0 (
        doc = """Enables additional stabilization pass in solver.
        """
    )
    float physxScene:frictionCorrelationDistance = 0.025 (
        doc = """Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not.
        Range: [0, inf) Default: 0.025 * tolerancesLength Units: distance
        """
    )
    float physxScene:frictionOffsetThreshold = 0.04 (
        doc = """A threshold of contact separation distance used to decide if a contact point will experience friction forces.
        Range: [0, inf) Default: 0.04 * tolerancesLength Units: distance
        """
    )
    uniform token physxScene:frictionType = "patch" (
        allowedTokens = ["patch"]
        doc = "Friction type used in simulation."
    )
    uint physxScene:gpuCollisionStackSize = 67108864 (
        doc = """Gpu collision stack size.
        """
    )
    uint physxScene:gpuFoundLostAggregatePairsCapacity = 1024 (
        doc = """Gpu found lost aggregate pairs capacity.
        """
    )
    uint physxScene:gpuFoundLostPairsCapacity = 262144 (
        doc = """Gpu found lost pairs capacity.
        """
    )
    uint physxScene:gpuHeapCapacity = 67108864 (
        doc = """Gpu heap capacity.
        """
    )
    uint physxScene:gpuMaxDeformableSurfaceContacts = 1048576 (
        doc = """Gpu max deformable surface contacts.
        """
    )
    uint physxScene:gpuMaxHairContacts = 1048576 (
        doc = """Gpu max hair contacts.
        """
    )
    uint physxScene:gpuMaxNumPartitions = 8 (
        doc = """Limitation for the partitions in the GPU dynamics pipeline.
        This variable must be a power of 2. A value greater than 32 is currently not supported.
        """
    )
    uint physxScene:gpuMaxParticleContacts = 1048576 (
        doc = """Gpu max particle contacts.
        """
    )
    uint physxScene:gpuMaxRigidContactCount = 524288 (
        doc = """Gpu max rigid contact count.
        """
    )
    uint physxScene:gpuMaxRigidPatchCount = 81920 (
        doc = """Gpu max rigid patch count.
        """
    )
    uint physxScene:gpuMaxSoftBodyContacts = 1048576 (
        doc = """Gpu max soft body contacts.
        """
    )
    uint64 physxScene:gpuTempBufferCapacity = 16777216 (
        doc = """Gpu temp buffer capacity.
        """
    )
    uint physxScene:gpuTotalAggregatePairsCapacity = 1024 (
        doc = """Gpu total aggregate pairs capacity.
        """
    )
    bool physxScene:invertCollisionGroupFilter = 0 (
        doc = '''Boolean attribute indicating whether inverted collision group filtering should be used.

        By default two collisions, that do have a collisionGroup set, collide with each other. 
        Adding a collisionGroup into a collisionGroup filtering will mean that the collision between those groups will be disabled. 
        This boolean attribute does invert the default behavior. Hence two collisions with defined collisionGroups will not collide with each other by default 
        and one does enable the collisions between the groups through the "CollisionGroup" filtering.
        '''
    )
    float physxScene:maxBiasCoefficient = inf (
        doc = """The maximum bias coefficient used in the constraint solver.
        Range: [0, inf) Units: dimensionless
        """
    )
    uniform uint physxScene:maxPositionIterationCount = 255 (
        doc = """Maximum position iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations. Range: [1, 255]"""
    )
    uniform uint physxScene:maxVelocityIterationCount = 255 (
        doc = """Maximum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
        Note that this setting will override solver iteration settings of individual actors that have requested more iterations. Range: [0, 255]"""
    )
    uniform uint physxScene:minPositionIterationCount = 1 (
        doc = """Minimum position iteration count for all actors (rigid bodies, cloth, particles etc).
        Range: [1, 255]"""
    )
    uniform uint physxScene:minVelocityIterationCount = 0 (
        doc = """Minimum velocity iteration count for all actors (rigid bodies, cloth, particles etc).
        Range: [0, 255]"""
    )
    bool physxScene:reportKinematicKinematicPairs = 0 (
        doc = """Boolean attribute indicating whether kinematic vs kinematic pairs generate contact reports.
        """
    )
    bool physxScene:reportKinematicStaticPairs = 0 (
        doc = """Boolean attribute indicating whether kinematic vs static pairs generate contact reports.
        """
    )
    uniform token physxScene:solverType = "TGS" (
        allowedTokens = ["TGS", "PGS"]
        doc = "Solver used for the simulation."
    )
    uint physxScene:timeStepsPerSecond = 60 (
        doc = """Simulation scene step defined as number of steps per second.
        Note that application might cap the number of simulation steps to avoid running more simulations steps with a low frame rate.
        """
    )
    uniform token physxScene:updateType = "Synchronous" (
        allowedTokens = ["Synchronous", "Asynchronous", "Disabled"]
        doc = "Type of update for a PhysX scene."
    )
}

class "PhysxSchemaPhysxSceneQuasistaticAPI" (
    doc = """
        PhysxSceneQuasistaticAPI defines quasistatic mode for simulation.

        The API must be applied to a UsdPhysics.PhysicsScene prim.

        In this mode actors are simulated/moved by the physics engine by obeying external forces and constraints as usual, but they do not accumulate momentum. 
        So that e.g. falling due to gravity is with constant speed, and motion stops as soon as external forces cease to apply. There is no conservation of momentum.

        By default all actors belonging to the scene have this behavior unless the collection does have the includes defined, then the collection definition does have a precendence.
    """
)
{
    bool physxSceneQuasistatic:enableQuasistatic = 1 (
        doc = """Whether the actors should behave quasistatic or not.
        """
    )
}

class "PhysxSchemaPhysxSDFMeshCollisionAPI" (
    doc = '''
        PhysX SDF mesh extended parameters.

        For any described attribute Fallback Value or Allowed Values below that are text/tokens, the actual token is published and defined in PhysxSchemaTokens. 
        So to set an attribute to the value "rightHanded", use PhysxSchemaTokens->rightHanded as the value.
    '''
)
{
    uniform token physxSDFMeshCollision:sdfBitsPerSubgridPixel = "BitsPerPixel16" (
        allowedTokens = ["BitsPerPixel8", "BitsPerPixel16", "BitsPerPixel32"]
        doc = """
        Values of 8, 16 and 32 bits per subgrid pixel are supported.

        Dense SDFs always use 32 bits per pixel. The less bits per pixel, the smaller the resulting SDF but also the less precise. 
        The SDF's memory consumption scales proportionally with the number of bits per subgrid pixel.
        """
    )
    uniform bool physxSDFMeshCollision:sdfEnableRemeshing = 0 (
        doc = """
        Enables optional remeshing as a preprocessing step before the SDF is computed.

        Remeshing can help generate valid SDF data even if the input mesh has bad properties like inconsistent winding or self-intersections. 
        The SDF distances (and therefore the collisions) will be slightly less accurate when remeshing is enabled.
        """
    )
    uniform float physxSDFMeshCollision:sdfMargin = 0.01 (
        doc = """
        Margin to increase the size of the SDF relative to the bounding box diagonal length of the mesh.

        A sdf margin value of 0.01 means the sdf boundary will be enlarged in any direction by 1% of the mesh's bounding box diagonal length.
        Representing the margin relative to the bounding box diagonal length ensures that it is scale independent. 
        Margins allow for precise distance queries in a region slightly outside of the mesh's bounding box. Range: [0, inf) Units: dimensionless
        """
    )
    uniform float physxSDFMeshCollision:sdfNarrowBandThickness = 0.01 (
        doc = """
        Size of the narrow band around the mesh surface where high resolution SDF samples are available.

        Outside of the narrow band, only low resolution samples are stored. 
        Representing the narrow band thickness as a fraction of the mesh's bounding box diagonal length ensures that it is scale independent. 
        A value of 0.01 is usually large enough. The smaller the narrow band thickness, the smaller the memory consumption of the sparse SDF. 
        Range: [0, 1] Units: dimensionless
        """
    )
    uniform int physxSDFMeshCollision:sdfResolution = 256 (
        doc = """
        The spacing of the uniformly sampled SDF is equal to the largest AABB extent of the mesh, divided by the resolution.

        Choose the lowest possible resolution that provides acceptable performance; very high resolution results in large memory consumption, 
        and slower cooking and simulation performance. Range: (1, inf)
        """
    )
    uniform int physxSDFMeshCollision:sdfSubgridResolution = 6 (
        doc = """
        A positive subgrid resolution enables sparsity on signed-distance-fields (SDF) while a value of 0 leads to the usage of a dense SDF.

        A value in the range of 4 to 8 is a reasonable compromise between block size and the overhead introduced by block addressing. 
        The smaller a block, the more memory is spent on the address table. The bigger a block, the less precisely the sparse SDF can adapt to the mesh's surface. 
        In most cases sparsity reduces the memory consumption of a SDF significantly. Range: [0, inf)
        """
    )
    uniform float physxSDFMeshCollision:sdfTriangleCountReductionFactor = 1 (
        doc = """
        Factor that quantifies the percentage of the input triangles to keep.

        1 means the input triangle mesh does not get modified. 
        0.5 would mean that the triangle count gets reduced to half the amount of the original mesh such that the collider needs to process less data. 
        This helps to speed up collision detection at the cost of a small geometric error. 
        Range: [0, 1] Units: dimensionless
        """
    )
}

