//
// Copyright 2023 Pixar
//
// Licensed under the terms set forth in the LICENSE.txt file available at
// https://openusd.org/license.
//
////////////////////////////////////////////////////////////////////////

/* ************************************************************************** */
/* **                                                                      ** */
/* ** This file is generated by a script.                                  ** */
/* **                                                                      ** */
/* ** Do not edit it directly (unless it is within a CUSTOM CODE section)! ** */
/* ** Edit hdSchemaDefs.py instead to make changes.                        ** */
/* **                                                                      ** */
/* ************************************************************************** */

#include "pxr/usdImaging/usdPhysicsImaging/driveSchema.h"

#include "pxr/imaging/hd/retainedDataSource.h"

#include "pxr/base/trace/trace.h"

// --(BEGIN CUSTOM CODE: Includes)--
// --(END CUSTOM CODE: Includes)--

PXR_NAMESPACE_OPEN_SCOPE

TF_DEFINE_PUBLIC_TOKENS(UsdPhysicsImagingDriveSchemaTokens,
    USD_PHYSICS_IMAGING_DRIVE_SCHEMA_TOKENS);

// --(BEGIN CUSTOM CODE: Schema Methods)--
// --(END CUSTOM CODE: Schema Methods)--

HdTokenDataSourceHandle
UsdPhysicsImagingDriveSchema::GetType() const
{
    return _GetTypedDataSource<HdTokenDataSource>(
        UsdPhysicsImagingDriveSchemaTokens->type);
}

HdFloatDataSourceHandle
UsdPhysicsImagingDriveSchema::GetMaxForce() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        UsdPhysicsImagingDriveSchemaTokens->maxForce);
}

HdFloatDataSourceHandle
UsdPhysicsImagingDriveSchema::GetTargetPosition() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        UsdPhysicsImagingDriveSchemaTokens->targetPosition);
}

HdFloatDataSourceHandle
UsdPhysicsImagingDriveSchema::GetTargetVelocity() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        UsdPhysicsImagingDriveSchemaTokens->targetVelocity);
}

HdFloatDataSourceHandle
UsdPhysicsImagingDriveSchema::GetDamping() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        UsdPhysicsImagingDriveSchemaTokens->damping);
}

HdFloatDataSourceHandle
UsdPhysicsImagingDriveSchema::GetStiffness() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        UsdPhysicsImagingDriveSchemaTokens->stiffness);
}

/*static*/
HdContainerDataSourceHandle
UsdPhysicsImagingDriveSchema::BuildRetained(
        const HdTokenDataSourceHandle &type,
        const HdFloatDataSourceHandle &maxForce,
        const HdFloatDataSourceHandle &targetPosition,
        const HdFloatDataSourceHandle &targetVelocity,
        const HdFloatDataSourceHandle &damping,
        const HdFloatDataSourceHandle &stiffness
)
{
    TfToken _names[6];
    HdDataSourceBaseHandle _values[6];

    size_t _count = 0;

    if (type) {
        _names[_count] = UsdPhysicsImagingDriveSchemaTokens->type;
        _values[_count++] = type;
    }

    if (maxForce) {
        _names[_count] = UsdPhysicsImagingDriveSchemaTokens->maxForce;
        _values[_count++] = maxForce;
    }

    if (targetPosition) {
        _names[_count] = UsdPhysicsImagingDriveSchemaTokens->targetPosition;
        _values[_count++] = targetPosition;
    }

    if (targetVelocity) {
        _names[_count] = UsdPhysicsImagingDriveSchemaTokens->targetVelocity;
        _values[_count++] = targetVelocity;
    }

    if (damping) {
        _names[_count] = UsdPhysicsImagingDriveSchemaTokens->damping;
        _values[_count++] = damping;
    }

    if (stiffness) {
        _names[_count] = UsdPhysicsImagingDriveSchemaTokens->stiffness;
        _values[_count++] = stiffness;
    }
    return HdRetainedContainerDataSource::New(_count, _names, _values);
}

UsdPhysicsImagingDriveSchema::Builder &
UsdPhysicsImagingDriveSchema::Builder::SetType(
    const HdTokenDataSourceHandle &type)
{
    _type = type;
    return *this;
}

UsdPhysicsImagingDriveSchema::Builder &
UsdPhysicsImagingDriveSchema::Builder::SetMaxForce(
    const HdFloatDataSourceHandle &maxForce)
{
    _maxForce = maxForce;
    return *this;
}

UsdPhysicsImagingDriveSchema::Builder &
UsdPhysicsImagingDriveSchema::Builder::SetTargetPosition(
    const HdFloatDataSourceHandle &targetPosition)
{
    _targetPosition = targetPosition;
    return *this;
}

UsdPhysicsImagingDriveSchema::Builder &
UsdPhysicsImagingDriveSchema::Builder::SetTargetVelocity(
    const HdFloatDataSourceHandle &targetVelocity)
{
    _targetVelocity = targetVelocity;
    return *this;
}

UsdPhysicsImagingDriveSchema::Builder &
UsdPhysicsImagingDriveSchema::Builder::SetDamping(
    const HdFloatDataSourceHandle &damping)
{
    _damping = damping;
    return *this;
}

UsdPhysicsImagingDriveSchema::Builder &
UsdPhysicsImagingDriveSchema::Builder::SetStiffness(
    const HdFloatDataSourceHandle &stiffness)
{
    _stiffness = stiffness;
    return *this;
}

HdContainerDataSourceHandle
UsdPhysicsImagingDriveSchema::Builder::Build()
{
    return UsdPhysicsImagingDriveSchema::BuildRetained(
        _type,
        _maxForce,
        _targetPosition,
        _targetVelocity,
        _damping,
        _stiffness
    );
}

/*static*/
UsdPhysicsImagingDriveSchema
UsdPhysicsImagingDriveSchema::GetFromParent(
        const HdContainerDataSourceHandle &fromParentContainer)
{
    return UsdPhysicsImagingDriveSchema(
        fromParentContainer
        ? HdContainerDataSource::Cast(fromParentContainer->Get(
                UsdPhysicsImagingDriveSchemaTokens->drive))
        : nullptr);
}

/*static*/
const TfToken &
UsdPhysicsImagingDriveSchema::GetSchemaToken()
{
    return UsdPhysicsImagingDriveSchemaTokens->drive;
}

/*static*/
const HdDataSourceLocator &
UsdPhysicsImagingDriveSchema::GetDefaultLocator()
{
    static const HdDataSourceLocator locator(GetSchemaToken());
    return locator;
}

/* static */
const HdDataSourceLocator &
UsdPhysicsImagingDriveSchema::GetTypeLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            UsdPhysicsImagingDriveSchemaTokens->type);
    return locator;
}

/* static */
const HdDataSourceLocator &
UsdPhysicsImagingDriveSchema::GetMaxForceLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            UsdPhysicsImagingDriveSchemaTokens->maxForce);
    return locator;
}

/* static */
const HdDataSourceLocator &
UsdPhysicsImagingDriveSchema::GetTargetPositionLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            UsdPhysicsImagingDriveSchemaTokens->targetPosition);
    return locator;
}

/* static */
const HdDataSourceLocator &
UsdPhysicsImagingDriveSchema::GetTargetVelocityLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            UsdPhysicsImagingDriveSchemaTokens->targetVelocity);
    return locator;
}

/* static */
const HdDataSourceLocator &
UsdPhysicsImagingDriveSchema::GetDampingLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            UsdPhysicsImagingDriveSchemaTokens->damping);
    return locator;
}

/* static */
const HdDataSourceLocator &
UsdPhysicsImagingDriveSchema::GetStiffnessLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            UsdPhysicsImagingDriveSchemaTokens->stiffness);
    return locator;
} 

PXR_NAMESPACE_CLOSE_SCOPE