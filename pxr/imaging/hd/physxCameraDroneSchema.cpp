//
// Copyright 2023 Pixar
//
// Licensed under the terms set forth in the LICENSE.txt file available at
// https://openusd.org/license.
//
////////////////////////////////////////////////////////////////////////

/* ************************************************************************** */
/* **                                                                      ** */
/* ** This file is generated by a script.                                  ** */
/* **                                                                      ** */
/* ** Do not edit it directly (unless it is within a CUSTOM CODE section)! ** */
/* ** Edit hdSchemaDefs.py instead to make changes.                        ** */
/* **                                                                      ** */
/* ************************************************************************** */

#include "pxr/imaging/hd/physxCameraDroneSchema.h"

#include "pxr/imaging/hd/retainedDataSource.h"

#include "pxr/base/trace/trace.h"

// --(BEGIN CUSTOM CODE: Includes)--
// --(END CUSTOM CODE: Includes)--

PXR_NAMESPACE_OPEN_SCOPE

TF_DEFINE_PUBLIC_TOKENS(HdPhysxCameraDroneSchemaTokens,
    HD_PHYSX_CAMERA_DRONE_SCHEMA_TOKENS);

// --(BEGIN CUSTOM CODE: Schema Methods)--
// --(END CUSTOM CODE: Schema Methods)--

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetFeedForwardVelocityGain() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->feedForwardVelocityGain);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetFollowDistance() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->followDistance);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetFollowHeight() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->followHeight);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetHorizontalVelocityGain() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->horizontalVelocityGain);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetMaxDistance() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->maxDistance);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetMaxSpeed() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->maxSpeed);
}

HdVec3fDataSourceHandle
HdPhysxCameraDroneSchema::GetPositionOffset() const
{
    return _GetTypedDataSource<HdVec3fDataSource>(
        HdPhysxCameraDroneSchemaTokens->positionOffset);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetRotationFilterTimeConstant() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->rotationFilterTimeConstant);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetVelocityFilterTimeConstant() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->velocityFilterTimeConstant);
}

HdFloatDataSourceHandle
HdPhysxCameraDroneSchema::GetVerticalVelocityGain() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdPhysxCameraDroneSchemaTokens->verticalVelocityGain);
}

/*static*/
HdContainerDataSourceHandle
HdPhysxCameraDroneSchema::BuildRetained(
        const HdFloatDataSourceHandle &feedForwardVelocityGain,
        const HdFloatDataSourceHandle &followDistance,
        const HdFloatDataSourceHandle &followHeight,
        const HdFloatDataSourceHandle &horizontalVelocityGain,
        const HdFloatDataSourceHandle &maxDistance,
        const HdFloatDataSourceHandle &maxSpeed,
        const HdVec3fDataSourceHandle &positionOffset,
        const HdFloatDataSourceHandle &rotationFilterTimeConstant,
        const HdFloatDataSourceHandle &velocityFilterTimeConstant,
        const HdFloatDataSourceHandle &verticalVelocityGain
)
{
    TfToken _names[10];
    HdDataSourceBaseHandle _values[10];

    size_t _count = 0;

    if (feedForwardVelocityGain) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->feedForwardVelocityGain;
        _values[_count++] = feedForwardVelocityGain;
    }

    if (followDistance) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->followDistance;
        _values[_count++] = followDistance;
    }

    if (followHeight) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->followHeight;
        _values[_count++] = followHeight;
    }

    if (horizontalVelocityGain) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->horizontalVelocityGain;
        _values[_count++] = horizontalVelocityGain;
    }

    if (maxDistance) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->maxDistance;
        _values[_count++] = maxDistance;
    }

    if (maxSpeed) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->maxSpeed;
        _values[_count++] = maxSpeed;
    }

    if (positionOffset) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->positionOffset;
        _values[_count++] = positionOffset;
    }

    if (rotationFilterTimeConstant) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->rotationFilterTimeConstant;
        _values[_count++] = rotationFilterTimeConstant;
    }

    if (velocityFilterTimeConstant) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->velocityFilterTimeConstant;
        _values[_count++] = velocityFilterTimeConstant;
    }

    if (verticalVelocityGain) {
        _names[_count] = HdPhysxCameraDroneSchemaTokens->verticalVelocityGain;
        _values[_count++] = verticalVelocityGain;
    }
    return HdRetainedContainerDataSource::New(_count, _names, _values);
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetFeedForwardVelocityGain(
    const HdFloatDataSourceHandle &feedForwardVelocityGain)
{
    _feedForwardVelocityGain = feedForwardVelocityGain;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetFollowDistance(
    const HdFloatDataSourceHandle &followDistance)
{
    _followDistance = followDistance;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetFollowHeight(
    const HdFloatDataSourceHandle &followHeight)
{
    _followHeight = followHeight;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetHorizontalVelocityGain(
    const HdFloatDataSourceHandle &horizontalVelocityGain)
{
    _horizontalVelocityGain = horizontalVelocityGain;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetMaxDistance(
    const HdFloatDataSourceHandle &maxDistance)
{
    _maxDistance = maxDistance;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetMaxSpeed(
    const HdFloatDataSourceHandle &maxSpeed)
{
    _maxSpeed = maxSpeed;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetPositionOffset(
    const HdVec3fDataSourceHandle &positionOffset)
{
    _positionOffset = positionOffset;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetRotationFilterTimeConstant(
    const HdFloatDataSourceHandle &rotationFilterTimeConstant)
{
    _rotationFilterTimeConstant = rotationFilterTimeConstant;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetVelocityFilterTimeConstant(
    const HdFloatDataSourceHandle &velocityFilterTimeConstant)
{
    _velocityFilterTimeConstant = velocityFilterTimeConstant;
    return *this;
}

HdPhysxCameraDroneSchema::Builder &
HdPhysxCameraDroneSchema::Builder::SetVerticalVelocityGain(
    const HdFloatDataSourceHandle &verticalVelocityGain)
{
    _verticalVelocityGain = verticalVelocityGain;
    return *this;
}

HdContainerDataSourceHandle
HdPhysxCameraDroneSchema::Builder::Build()
{
    return HdPhysxCameraDroneSchema::BuildRetained(
        _feedForwardVelocityGain,
        _followDistance,
        _followHeight,
        _horizontalVelocityGain,
        _maxDistance,
        _maxSpeed,
        _positionOffset,
        _rotationFilterTimeConstant,
        _velocityFilterTimeConstant,
        _verticalVelocityGain
    );
}

/*static*/
HdPhysxCameraDroneSchema
HdPhysxCameraDroneSchema::GetFromParent(
        const HdContainerDataSourceHandle &fromParentContainer)
{
    return HdPhysxCameraDroneSchema(
        fromParentContainer
        ? HdContainerDataSource::Cast(fromParentContainer->Get(
                HdPhysxCameraDroneSchemaTokens->physxCameraDrone))
        : nullptr);
}

/*static*/
const TfToken &
HdPhysxCameraDroneSchema::GetSchemaToken()
{
    return HdPhysxCameraDroneSchemaTokens->physxCameraDrone;
}

/*static*/
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetDefaultLocator()
{
    static const HdDataSourceLocator locator(GetSchemaToken());
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetFeedForwardVelocityGainLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->feedForwardVelocityGain);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetFollowDistanceLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->followDistance);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetFollowHeightLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->followHeight);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetHorizontalVelocityGainLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->horizontalVelocityGain);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetMaxDistanceLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->maxDistance);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetMaxSpeedLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->maxSpeed);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetPositionOffsetLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->positionOffset);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetRotationFilterTimeConstantLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->rotationFilterTimeConstant);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetVelocityFilterTimeConstantLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->velocityFilterTimeConstant);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdPhysxCameraDroneSchema::GetVerticalVelocityGainLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdPhysxCameraDroneSchemaTokens->verticalVelocityGain);
    return locator;
} 

PXR_NAMESPACE_CLOSE_SCOPE