//
// Copyright 2023 Pixar
//
// Licensed under the terms set forth in the LICENSE.txt file available at
// https://openusd.org/license.
//
////////////////////////////////////////////////////////////////////////

/* ************************************************************************** */
/* **                                                                      ** */
/* ** This file is generated by a script.                                  ** */
/* **                                                                      ** */
/* ** Do not edit it directly (unless it is within a CUSTOM CODE section)! ** */
/* ** Edit hdSchemaDefs.py instead to make changes.                        ** */
/* **                                                                      ** */
/* ************************************************************************** */

#include "pxr/imaging/hd/driveSchema.h"

#include "pxr/imaging/hd/retainedDataSource.h"

#include "pxr/base/trace/trace.h"

// --(BEGIN CUSTOM CODE: Includes)--
// --(END CUSTOM CODE: Includes)--

PXR_NAMESPACE_OPEN_SCOPE

TF_DEFINE_PUBLIC_TOKENS(HdDriveSchemaTokens,
    HD_DRIVE_SCHEMA_TOKENS);

// --(BEGIN CUSTOM CODE: Schema Methods)--
// --(END CUSTOM CODE: Schema Methods)--

HdTokenDataSourceHandle
HdDriveSchema::GetName() const
{
    return _GetTypedDataSource<HdTokenDataSource>(
        HdDriveSchemaTokens->name);
}

HdTokenDataSourceHandle
HdDriveSchema::GetType() const
{
    return _GetTypedDataSource<HdTokenDataSource>(
        HdDriveSchemaTokens->type);
}

HdFloatDataSourceHandle
HdDriveSchema::GetMaxForce() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdDriveSchemaTokens->maxForce);
}

HdFloatDataSourceHandle
HdDriveSchema::GetTargetPosition() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdDriveSchemaTokens->targetPosition);
}

HdFloatDataSourceHandle
HdDriveSchema::GetTargetVelocity() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdDriveSchemaTokens->targetVelocity);
}

HdFloatDataSourceHandle
HdDriveSchema::GetDamping() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdDriveSchemaTokens->damping);
}

HdFloatDataSourceHandle
HdDriveSchema::GetStiffness() const
{
    return _GetTypedDataSource<HdFloatDataSource>(
        HdDriveSchemaTokens->stiffness);
}

/*static*/
HdContainerDataSourceHandle
HdDriveSchema::BuildRetained(
        const HdTokenDataSourceHandle &name,
        const HdTokenDataSourceHandle &type,
        const HdFloatDataSourceHandle &maxForce,
        const HdFloatDataSourceHandle &targetPosition,
        const HdFloatDataSourceHandle &targetVelocity,
        const HdFloatDataSourceHandle &damping,
        const HdFloatDataSourceHandle &stiffness
)
{
    TfToken _names[7];
    HdDataSourceBaseHandle _values[7];

    size_t _count = 0;

    if (name) {
        _names[_count] = HdDriveSchemaTokens->name;
        _values[_count++] = name;
    }

    if (type) {
        _names[_count] = HdDriveSchemaTokens->type;
        _values[_count++] = type;
    }

    if (maxForce) {
        _names[_count] = HdDriveSchemaTokens->maxForce;
        _values[_count++] = maxForce;
    }

    if (targetPosition) {
        _names[_count] = HdDriveSchemaTokens->targetPosition;
        _values[_count++] = targetPosition;
    }

    if (targetVelocity) {
        _names[_count] = HdDriveSchemaTokens->targetVelocity;
        _values[_count++] = targetVelocity;
    }

    if (damping) {
        _names[_count] = HdDriveSchemaTokens->damping;
        _values[_count++] = damping;
    }

    if (stiffness) {
        _names[_count] = HdDriveSchemaTokens->stiffness;
        _values[_count++] = stiffness;
    }
    return HdRetainedContainerDataSource::New(_count, _names, _values);
}

HdDriveSchema::Builder &
HdDriveSchema::Builder::SetName(
    const HdTokenDataSourceHandle &name)
{
    _name = name;
    return *this;
}

HdDriveSchema::Builder &
HdDriveSchema::Builder::SetType(
    const HdTokenDataSourceHandle &type)
{
    _type = type;
    return *this;
}

HdDriveSchema::Builder &
HdDriveSchema::Builder::SetMaxForce(
    const HdFloatDataSourceHandle &maxForce)
{
    _maxForce = maxForce;
    return *this;
}

HdDriveSchema::Builder &
HdDriveSchema::Builder::SetTargetPosition(
    const HdFloatDataSourceHandle &targetPosition)
{
    _targetPosition = targetPosition;
    return *this;
}

HdDriveSchema::Builder &
HdDriveSchema::Builder::SetTargetVelocity(
    const HdFloatDataSourceHandle &targetVelocity)
{
    _targetVelocity = targetVelocity;
    return *this;
}

HdDriveSchema::Builder &
HdDriveSchema::Builder::SetDamping(
    const HdFloatDataSourceHandle &damping)
{
    _damping = damping;
    return *this;
}

HdDriveSchema::Builder &
HdDriveSchema::Builder::SetStiffness(
    const HdFloatDataSourceHandle &stiffness)
{
    _stiffness = stiffness;
    return *this;
}

HdContainerDataSourceHandle
HdDriveSchema::Builder::Build()
{
    return HdDriveSchema::BuildRetained(
        _name,
        _type,
        _maxForce,
        _targetPosition,
        _targetVelocity,
        _damping,
        _stiffness
    );
}

/*static*/
HdDriveSchema
HdDriveSchema::GetFromParent(
        const HdContainerDataSourceHandle &fromParentContainer)
{
    return HdDriveSchema(
        fromParentContainer
        ? HdContainerDataSource::Cast(fromParentContainer->Get(
                HdDriveSchemaTokens->drive))
        : nullptr);
}

/*static*/
const TfToken &
HdDriveSchema::GetSchemaToken()
{
    return HdDriveSchemaTokens->drive;
}

/*static*/
const HdDataSourceLocator &
HdDriveSchema::GetDefaultLocator()
{
    static const HdDataSourceLocator locator(GetSchemaToken());
    return locator;
}

/* static */
const HdDataSourceLocator &
HdDriveSchema::GetNameLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdDriveSchemaTokens->name);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdDriveSchema::GetTypeLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdDriveSchemaTokens->type);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdDriveSchema::GetMaxForceLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdDriveSchemaTokens->maxForce);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdDriveSchema::GetTargetPositionLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdDriveSchemaTokens->targetPosition);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdDriveSchema::GetTargetVelocityLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdDriveSchemaTokens->targetVelocity);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdDriveSchema::GetDampingLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdDriveSchemaTokens->damping);
    return locator;
}

/* static */
const HdDataSourceLocator &
HdDriveSchema::GetStiffnessLocator()
{
    static const HdDataSourceLocator locator =
        GetDefaultLocator().Append(
            HdDriveSchemaTokens->stiffness);
    return locator;
} 

PXR_NAMESPACE_CLOSE_SCOPE